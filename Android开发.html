<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Android开发 - 博客未命名
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="博客未命名" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:lixindong.top ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="http://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; 博客未命名</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
       
       <li><a href="index.html">HOME</a></li>
    <li><a href="archives.html">Archives</a></li>
    <li><a href="about.html">ABOUT</a></li>

    <li><label>Categories</label></li>

        
            <li><a href="%E7%94%9F%E6%B4%BB%E6%97%A5%E5%B8%B8.html">生活日常</a></li>
        
            <li><a href="%E7%BB%98%E7%94%BB.html">绘画</a></li>
        
            <li><a href="Android%E5%BC%80%E5%8F%91.html">Android开发</a></li>
        
            <li><a href="%E4%BA%A7%E5%93%81%E6%83%B3%E6%B3%95.html">产品想法</a></li>
        
            <li><a href="%E5%90%89%E5%AE%83%E5%AD%A6%E4%B9%A0%F0%9F%8E%B8.html">吉它学习🎸</a></li>
        
            <li><a href="web%E5%BC%80%E5%8F%91.html">web开发</a></li>
        
            <li><a href="%E4%B9%A6%E7%B1%8D%E7%94%B5%E5%BD%B1.html">书籍电影</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="14864276588598.html">
                
                  <h1>深入理解LayoutInflater.inflate()</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><a href="https://www.bignerdranch.com/blog/understanding-androids-layoutinflater-inflate/">原文链接：https://www.bignerdranch.com/blog/understanding-androids-layoutinflater-inflate/</a><br/>
<a href="http://blog.chengdazhi.com/index.php/110">译文链接：http://blog.chengdazhi.com/index.php/110</a></p>

<p>由于我们很容易习惯公式化的预置代码，有时我们会忽略很优雅的细节。LayoutInflater以及它在Fragment的onCreateView()中填充View的方式带给我的就是这样的感受。这个类用于将XML文件转换成相对应的ViewGroup和控件Widget。我尝试在Google官方文档与网络上其他讨论中寻找有关的说明，而后发现许多人<strong>不但不清楚LayoutInflater的inflate()方法的细节，而且甚至在误用它。</strong></p>

<p>这里的困惑很大程度上是因为Google上有关attachToRoot（也就是inflate()方法第三个参数）的文档太模糊：</p>

<blockquote>
<p>被填充的层是否应该附在root参数内部？如果是false，root参数只适用于为XML根元素View创建正确的LayoutParams的子类。</p>
</blockquote>

<p>其实意思就是：<strong>如果attachToRoot是true的话，那第一个参数的layout文件就会被填充并附加在第二个参数所指定的ViewGroup内。方法返回结合后的View，根元素是第二个参数ViewGroup。如果是false的话，第一个参数所指定的layout文件会被填充并作为View返回。这个View的根元素就是layout文件的根元素。不管是true还是false，都需要ViewGroup的LayoutParams来正确的测量与放置layout文件所产生的View对象。</strong></p>

<p>attachToRoot传入true代表layout文件填充的View会被直接添加进ViewGroup，而传入false则代表创建的View会以其他方式被添加进ViewGroup。</p>

<p>让我们就两种情况多举一些例子来更深入的理解。</p>

<h1 id="toc_0">attachToRoot是True</h1>

<p>假设我们在XML layout文件中写了一个Button并指定了宽高为match_parent。<br/>
<code><br/>
&lt;Button xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;<br/>
android:layout_width=&quot;match_parent&quot;<br/>
android:layout_height=&quot;match_parent&quot;<br/>
android:id=&quot;@+id/custom_button&quot;&gt;<br/>
&lt;/Button&gt;<br/>
</code></p>

<p>现在我们想动态地把这个按钮添加进Fragment或Activity的LinearLayout中。如果这里LinearLayout已经是一个成员变量mLinearLayout了，我们只需要通过如下代码达成目标：</p>

<pre><code>inflater.inflate(R.layout.custom_button, mLinearLayout, true);
</code></pre>

<p>我们指定了用于填充button的layout资源文件，然后我们告诉LayoutInflater我们想把button添加到mLinearLayout中。这里Button的LayoutParams种类为LinearLayout.LayoutParams。</p>

<p>下面的代码也有同样的效果。LayoutInflater的两个参数的inflate()方法自动将attachToRoot设置为true。</p>

<pre><code>inflater.inflate(R.layout.custom_button, mLinearLayout);
</code></pre>

<p>另一种在attachToRoot中传递true的情况是使用自定义View。我们看一个layout文件中根元素有<merge>标签的例子。<merge>标签标识着这个layout文件的根ViewGroup可以有多种类型。</p>

<pre><code>public class MyCustomView extends LinearLayout {
...
private void init() {
LayoutInflater inflater = LayoutInflater.from(getContext());
inflater.inflate(R.layout.view_with_merge_tag, this);
}
}
</code></pre>

<p>这就是一个很好的使用attachToRoot的例子。这个例子中layout文件没有ViewGroup作为根元素，所以我们指定我们自定义的LinearLayout作为根元素。如果layout文件有一个FrameLayout作为根元素而不是<merge>，那么FrameLayout和它的子元素都可以正常填充，而后都会被添加到LinearLayout中，LinearLayout是根ViewGroup，包含着FrameLayout和其子元素。</merge></p>

<h1 id="toc_1">attachToRoot是False</h1>

<p>我们看一下什么时候attachToRoot应该是false。在这种情况下，inflate()方法中的第一个参数所指定的View不会被添加到第二个参数所指定的ViewGroup中。</p>

<p>回忆一下刚才的例子中的Button，我们想通过layout文件添加自定义的Button至mLinearLayout中。当attachToRoot为false时，我们仍可以将Button添加到mLinearLayout中，但是这需要我们自己动手。</p>

<pre><code>Button button = (Button) inflater.inflate(R.layout.custom_button, mLinearLayout, false);
mLinearLayout.addView(button);
</code></pre>

<p>这两行代码与刚才attachToRoot为true时的一行代码等效。通过传入false，我们告诉LayoutInflater我们不暂时还想将View添加到根元素ViewGroup中，意思是我们一会儿再添加。在这个例子中，一会儿再添加就是在inflate()后调用addView()方法。</p>

<p>在将attachToRoot设置为false的例子中，由于要手动添加View进ViewGroup导致代码变多了。将Button添加到LinearLayout中还是用一行代码直接将attachToRoot设置为true简便一些。下面我们看一下什么情况下attachToRoot必须传入false。</p>

<p>每一个RecyclerView的子元素都要在attachToRoot设置为false的情况下填充。这里子View在onCreateViewHolder()中填充。</p>

<pre><code>public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
LayoutInflater inflater = LayoutInflater.from(getActivity());
View view = inflater.inflate(android.R.layout.list_item_recyclerView, parent, false);
return new ViewHolder(view);
}
</code></pre>

<p>RecyclerView负责决定什么时候展示它的子View，这个不由我们决定。在任何我们不负责将View添加进ViewGroup的情况下都应该将attachToRoot设置为false。</p>

<p>当在Fragment的onCreateView()方法中填充并返回View时，要将attachToRoot设为false。如果传入true，会抛出IllegalStateException，因为指定的子View已经有父View了。你需要指定在哪里将Fragment的View放进Activity里，而添加、移除或替换Fragment则是FragmentManager的事情。</p>

<pre><code>FragmentManager fragmentManager = getSupportFragmentManager();
Fragment fragment = fragmentManager.findFragmentById(R.id.root_viewGroup);

if (fragment == null) {
fragment = new MainFragment();
fragmentManager.beginTransaction().add(R.id.root_viewGroup, fragment).commit();
}
</code></pre>

<p>上面代码中root_viewGroup就是Activity中用于放置Fragment的容器，它会作为inflate()方法中的第二个参数被传入onCreateView()中。它也是你在inflate()方法中传入的ViewGroup。FragmentManager会将Fragment的View添加到ViewGroup中，你可不想添加两次。</p>

<pre><code>public View onCreateView(LayoutInflater inflater, ViewGroup parentViewGroup, Bundle savedInstanceState) {
View view = inflater.inflate(R.layout.fragment_layout, parentViewGroup, false);
…
return view;
}
</code></pre>

<p>问题是：如果我们不需在onCreateView()中将View添加进ViewGroup，为什么还要传入ViewGroup呢？为什么inflate()方法必须要传入根ViewGroup？</p>

<p>原因是及时不需要马上将新填充的View添加进ViewGroup，我们还是需要这个父元素的LayoutParams来在将来添加时决定View的size和position。</p>

<p>你在网上一定会遇到一些不正确的建议。有些人会建议你如果将attachToRoot设置为false的话直接将根ViewGroup传入null。但是，如果有父元素的话，还是应该传入的。</p>

<p><img src="http://upload-images.jianshu.io/upload_images/25769-f6a7daf1df51f931.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="null-root"/></p>

<p>Lint会警告你不要讲null作为root传入。你的App不会挂掉，但是可能会表现异常。当你的子View没有正确的LayoutParams时，它会自己通过<a href="http://developer.android.com/reference/android/view/ViewGroup.html#generateDefaultLayoutParams()">generateDefaultLayoutParams</a>计算。</p>

<p>你可能并不想要这些默认的LayoutParams。你在XML指定的LayoutParams会被忽略。我们可能已经指定了子View要填充父元素的宽度，但父View又wrap_content导致最终的View小很多。</p>

<p>下面是一种没有ViewGroup作为root传入inflate()方法的情况。当为AlertDialog创建自定义View时，还无法访问父元素。</p>

<pre><code>AlertDialog.Builder dialogBuilder = new AlertDialog.Builder(mContext);
View customView = inflater.inflate(R.layout.custom_alert_dialog, null);
...
dialogBuilder.setView(customView);
dialogBuilder.show();
</code></pre>

<p>在这种情况下，可以将null作为root ViewGroup传入。后来我发现AlertDialog还是会重写LayoutParams并设置各项参数为match_parent。但是，规则还是在有ViewGroup可以传入时传入它。</p>

<h1 id="toc_2">避开崩溃、异常表现与误解</h1>

<p>希望这篇文章可以帮助你在使用LayoutInflater时避开崩溃、异常表现与误解。下面整理了文章的要点：</p>

<ul>
<li>  如果可以传入ViewGroup作为根元素，那就传入它。</li>
<li>  避免将null作为根ViewGroup传入。</li>
<li>  当我们不负责将layout文件的View添加进ViewGroup时设置attachToRoot参数为false。</li>
<li>  不要在View已经被添加进ViewGroup时传入true。</li>
<li>  自定义View时很适合将attachToRoot设置为true。</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/2/7</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android%E5%BC%80%E5%8F%91.html'>Android开发</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14730898296691.html">
                
                  <h1>Android中 Integer对象使用==运算符还是equals()方法比较大小?</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>最近项目组使用findbugs辅助检测代码问题，其中一个问题提到了Integer对象的值比较问题。虽然心里很清楚，java语言类对象的双等号操作符默认比较的是对象的地址，即是否是同一个对象。可是对于Integer、Long这类基本类型的扩展类，心想存在特殊处理的可能，所以还是查了下资料，主要是解释一些心里的疑惑。</p>

<h2 id="toc_0">疑问?</h2>

<ol>
<li>java 能不能重载+、-、 =、==这些运算符</li>
<li>java的Integer、Long这些类型的==运算符是比较地址还是使用<code>equals</code>的结果</li>
<li>为什么两个值为10的Integer对象，用==比较的结果是true，而两个值为1000的Integer对象的比较结果为false?</li>
</ol>

<h2 id="toc_1">解答！</h2>

<h3 id="toc_2">1. 能不能重载运算符？</h3>

<p>不能。<br/>
有些人疑问，可是String对象可以有形如<code>&quot;hello worl&quot; + &#39;d&#39;</code>的操作，基本运算应该是不支持的。<br/>
这里是因为编译器在编译时处理成了<code>Object s2 = (new StringBuilder(&quot;hello world&quot;)).append(&#39;d&#39;).toString();</code>的形式。</p>

<h3 id="toc_3">2. java的Integer、Long这些类型的==运算符是比较地址还是使用<code>equals</code>的结果?</h3>

<p>比较地址。<br/>
因为不能重载运算符，所以即便是这些特殊的类，依然只能在编译器上动动手脚。</p>

<h3 id="toc_4">3. 为什么两个值为10的Integer对象，用==比较的结果是true，而两个值为1000的Integer对象的比较结果为false?</h3>

<p>Integer为-128~127范围内的对象做了缓存处理。<br/>
<code><br/>
public static Integer valueOf(int i) {<br/>
    if(i &gt;= -128 &amp;&amp; i &lt;= IntegerCache.high)<br/>
        return IntegerCache.cache[i + 128];<br/>
    else<br/>
        return new Integer(i);<br/>
}<br/>
</code><br/>
无论你是使用new Integer(..)还是Integer.valueOf(..)获取对象，<br/>
只要值在-128到127的范围内，拿到的就是缓存好的对象。因此无论是<code>==运算符</code>还是equals()方法，只要值相同，结果都是true。<br/>
而如果你的值在这个范围之外，<code>==</code>必然返回false，equals()方法的返回值依对象的值而定。</p>

<h2 id="toc_5">结论</h2>

<p>无论如何，请使用equals()方法比较大小。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/9/5</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android%E5%BC%80%E5%8F%91.html'>Android开发</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14730873130757.html">
                
                  <h1>如何在Java中避免equals方法的隐藏陷阱</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>今天看资料时看到coolshell的这篇文章，获益匪浅，收藏到文库里。</p>

<p>译文原文：<a href="http://coolshell.cn/articles/1051.html">http://coolshell.cn/articles/1051.html</a><br/>
英文原文：<a href="http://www.artima.com/lejava/articles/equality.html">http://www.artima.com/lejava/articles/equality.html</a></p>

<p><strong>译者注</strong> :你可能会觉得Java很简单，Object的equals实现也会非常简单，但是事实并不是你想象的这样，耐心的读完本文，你会发现你对Java了解的是如此的少。如果这篇文章是一份Java程序员的入职笔试，那么不知道有多少人会掉落到这样的陷阱中。原文转自<a href="http://www.artima.com/lejava/articles/equality.html">http://www.artima.com/lejava/articles/equality.html</a> 三位作者都是不同领域的大拿，有兴趣的读者可以从上面这个连接直接去阅读原文。</p>

<p><strong>摘要</strong></p>

<p>本文描述重载equals方法的技术，这种技术即使是具现类的子类增加了字段也能保证equal语义的正确性。</p>

<p>在《Effective Java》的第8项中，Josh Bloch描述了当继承类作为面向对象语言中的等价关系的基础问题，要保证派生类的equal正确性语义所会面对的困难。Bloch这样写到：</p>

<blockquote>
<p><strong>除非你忘记了面向对象抽象的好处，否则在当你继承一个新类或在类中增加了一个值组件时你无法同时保证equal的语义依然正确</strong></p>
</blockquote>

<p>在《Programming in Scala》中的第28章演示了一种方法，这种方法允许即使继承了新类，增加了新的值组件，equal的语义仍然能得到保证。虽然在这本书中这项技术是在使用Scala类环境中，但是这项技术同样可以应用于Java定义的类中。在本文中的描述来自于Programming in Scala中的文字描述，但是代码被我从scala翻译成了Java</p>

<h4 id="toc_0">常见的等价方法陷阱</h4>

<p>java.lang.Object 类定义了equals这个方法，它的子类可以通过重载来覆盖它。不幸的是，在面向对象中写出正确的equals方法是非常困难的。事实上，在研究了大量的Java代码后，2007 paper的作者得出了如下的一个结论：</p>

<blockquote>
<p>几乎所有的equals方法的实现都是错误的！</p>
</blockquote>

<p>这个问题是因为等价是和很多其他的事物相关联。例如其中之一，一个的类型C的错误等价方法可能意味着你无法将这个类型C的对象可信赖的放入到容器中。比如说，你有两个元素elem1和elem2他们都是类型C的对象，并且他们是相等，即<code>elem1.equals(elm2)</code>返回ture。但是，只要这个equals方法是错误的实现，那么你就有可能会看见如下的一些行为：</p>

<pre><code>Set hashSet&lt;C&gt; = new java.util.HashSet&lt;C&gt;();
hashSet.add(elem1);
hashSet.contains(elem2);    // returns false!&lt;/pre&gt;
</code></pre>

<p>当equals重载时，这里有4个会引发equals行为不一致的常见陷阱：</p>

<ol>
<li> 定义了错误的equals方法签名(signature) Defining equals with the wrong signature.</li>
<li> 重载了equals的但没有同时重载hashCode的方法。 Changing equals without also changing hashCode.</li>
<li> 建立在会变化字域上的equals定义。 Defining equals in terms of mutable fields.</li>
<li> 不满足等价关系的equals错误定义 Failing to define equals as an equivalence relation.</li>
</ol>

<p>在剩下的章节中我们将依次讨论这4中陷阱。</p>

<h4 id="toc_1">陷阱1：定义错误equals方法签名(signature)</h4>

<p>考虑为下面这个简单类Point增加一个等价性方法：</p>

<pre><code>public class Point {

    private final int x;
    private final int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    // ...
}
</code></pre>

<p>看上去非常明显，但是按照这种方式来定义equals就是错误的。</p>

<pre><code>// An utterly wrong definition of equals
public boolean equals(Point other) {
  return (this.getX() == other.getX() &amp;&amp; this.getY() == other.getY());
}
</code></pre>

<p>这个方法有什么问题呢？初看起来，它工作的非常完美：</p>

<pre><code>Point p1 = new Point(1, 2);
Point p2 = new Point(1, 2);

Point q = new Point(2, 3);

System.out.println(p1.equals(p2)); // prints true

System.out.println(p1.equals(q)); // prints false
</code></pre>

<p>然而，当我们一旦把这个Point类的实例放入到一个容器中问题就出现了：</p>

<pre><code>import java.util.HashSet;

HashSet&lt;Point&gt; coll = new HashSet&lt;Point&gt;();
coll.add(p1);

System.out.println(coll.contains(p2)); // prints false
</code></pre>

<p>为什么coll中没有包含p2呢？甚至是p1也被加到集合里面，p1和p2是是等价的对象吗？在下面的程序中，我们可以找到其中的一些原因，定义p2a是一个指向p2的对象，但是p2a的类型是Object而非Point类型：</p>

<pre><code>Object p2a = p2;
</code></pre>

<p>现在我们重复第一个比较，但是不再使用p2而是p2a,我们将会得到如下的结果：</p>

<pre><code>System.out.println(p1.equals(p2a)); // prints false
</code></pre>

<p>到底是那里出了了问题？事实上，之前所给出的equals版本并没有覆盖Object类的equals方法，因为他的类型不同。下面是Object的equals方法的定义</p>

<pre><code>public boolean equals(Object other)
</code></pre>

<p>因为Point类中的equals方法使用的是以Point类而非Object类做为参数，因此它并没有覆盖Object中的equals方法。而是一种变化了的重载。在Java中重载被解析为静态的参数类型而非运行期的类型，因此当静态参数类型是Point,Point的equals方法就被调用。然而当静态参数类型是Object时，Object类的equals就被调用。因为这个方法并没有被覆盖，因此它仍然是实现成比较对象标示。这就是为什么虽然p1和p2a具有同样的x,y值，”p1.equals(p2a)”仍然返回了false。这也是会什么HasSet的contains方法返回false的原因，因为这个方法操作的是泛型，他调用的是一般化的Object上equals方法而非Point类上变化了的重载方法equals</p>

<p>一个更好但不完美的equals方法定义如下：</p>

<pre><code>// A better definition, but still not perfect
@Override public boolean equals(Object other) {
    boolean result = false;
    if (other instanceof Point) {
        Point that = (Point) other;
        result = (this.getX() == that.getX() &amp;&amp; this.getY() == that.getY());
    }
    return result;
}
</code></pre>

<p>现在equals有了正确的类型，它使用了一个Object类型的参数和一个返回布尔型的结果。这个方法的实现使用instanceof操作和做了一个造型。它首先检查这个对象是否是一个Point类，如果是，他就比较两个点的坐标并返回结果，否则返回false。</p>

<h4 id="toc_2">陷阱2：重载了equals的但没有同时重载hashCode的方法</h4>

<p>如果你使用上一个定义的Point类进行p1和p2a的反复比较，你都会得到你预期的true的结果。但是如果你将这个类对象放入到HashSet.contains()方法中测试，你就有可能仍然得到false的结果：</p>

<pre><code>Point p1 = new Point(1, 2);
Point p2 = new Point(1, 2);

HashSet&lt;Point&gt; coll = new HashSet&lt;Point&gt;();
coll.add(p1);

System.out.println(coll.contains(p2)); // 打印 false (有可能)
</code></pre>

<p>事实上，这个个结果不是100%的false，你也可能有返回ture的经历。如果你得到的结果是true的话，那么你试试其他的坐标值，最终你一定会得到一个在集合中不包含的结果。导致这个结果的原因是Point重载了equals却没有重载hashCode。</p>

<p>注意上面例子的的容器是一个HashSet，这就意味着容器中的元素根据他们的哈希码被被放入到”哈希桶 hash buckets”中。contains方法首先根据哈希码在哈希桶中查找，然后让桶中的所有元素和所给的参数进行比较。现在，虽然最后一个Point类的版本重定义了equals方法，但是它并没有同时重定义hashCode。因此，hashCode仍然是Object类的那个版本，即：所分配对象的一个地址的变换。所以p1和p2的哈希码理所当然的不同了，甚至是即时这两个点的坐标完全相同。不同的哈希码导致他们具有极高的可能性被放入到集合中不同的哈希桶中。contains方法将会去找p2的哈希码对应哈希桶中的匹配元素。但是大多数情况下，p1一定是在另外一个桶中，因此，p2永远找不到p1进行匹配。当然p2和p2也可能偶尔会被放入到一个桶中，在这种情况下，contains的结果就为true了。</p>

<p>最新一个Point类实现的问题是，它的实现违背了作为Object类的定义的hashCode的语义。</p>

<blockquote>
<p>如果两个对象根据equals(Object)方法是相等的，那么在这两个对象上调用hashCode方法应该产生同样的值</p>
</blockquote>

<p>事实上，在Java中，hashCode和equals需要一起被重定义是众所周知的。此外，hashCode只可以依赖于equals依赖的域来产生值。对于Point这个类来说，下面的的hashCode定义是一个非常合适的定义。</p>

<pre><code>public class Point {

    private final int x;
    private final int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    @Override public boolean equals(Object other) {
        boolean result = false;
        if (other instanceof Point) {
            Point that = (Point) other;
            result = (this.getX() == that.getX() &amp;&amp; this.getY() == that.getY());
        }
        return result;
    }

    @Override public int hashCode() {
        return (41 * (41 + getX()) + getY());
    }

}
</code></pre>

<p>这只是hashCode一个可能的实现。x域加上常量41后的结果再乘与41并将结果在加上y域的值。这样做就可以以低成本的运行时间和低成本代码大小得到一个哈希码的合理的分布(<strong>译者注：</strong>性价比相对较高的做法)。</p>

<p>增加hashCode方法重载修正了定义类似Point类等价性的问题。然而，关于类的等价性仍然有其他的问题点待发现。</p>

<h4 id="toc_3">陷阱3：建立在会变化字段上的equals定义</h4>

<p>让我们在Point类做一个非常微小的变化</p>

<pre><code>public class Point {

    private int x;
    private int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    public void setX(int x) { // Problematic
        this.x = x;
    }

    public void setY(int y) {
        this.y = y;
    }

    @Override public boolean equals(Object other) {
        boolean result = false;
        if (other instanceof Point) {
            Point that = (Point) other;
            result = (this.getX() == that.getX() &amp;&amp; this.getY() == that.getY());
        }
        return result;
    }

    @Override public int hashCode() {
        return (41 * (41 + getX()) + getY());
    }
}
</code></pre>

<p>唯一的不同是x和y域不再是final，并且两个set方法被增加到类中来，并允许客户改变x和y的值。equals和hashCode这个方法的定义现在是基于在这两个会发生变化的域上，因此当他们的域的值改变时，结果也就跟着改变。因此一旦你将这个point对象放入到集合中你将会看到非常神奇的效果。</p>

<pre><code>Point p = new Point(1, 2);

HashSet&lt;Point&gt; coll = new HashSet&lt;Point&gt;();
coll.add(p);

System.out.println(coll.contains(p)); // 打印 true
</code></pre>

<p>现在如果你改变p中的一个域，这个集合中还会包含point吗，我们将拭目以待。</p>

<pre><code>p.setX(p.getX() + 1);

System.out.println(coll.contains(p)); // (有可能)打印 false
</code></pre>

<p>看起来非常的奇怪。p去那里去了？如果你通过集合的迭代器来检查p是否包含，你将会得到更奇怪的结果。</p>

<pre><code>Iterator&lt;Point&gt; it = coll.iterator();
boolean containedP = false;
while (it.hasNext()) {
    Point nextP = it.next();
    if (nextP.equals(p)) {
        containedP = true;
        break;
    }
}

System.out.println(containedP); // 打印 true
</code></pre>

<p>结果是，集合中不包含p，但是p在集合的元素中！到底发生了什么！当然，所有的这一切都是在x域的修改后才发生的，p最终的的hashCode是在集合coll错误的哈希桶中。即，原始哈希桶不再有其新值对应的哈希码。换句话说，p已经在集合coll的是视野范围之外，虽然他仍然属于coll的元素。</p>

<p>从这个例子所得到的教训是，当equals和hashCode依赖于会变化的状态时，那么就会给用户带来问题。如果这样的对象被放入到集合中，用户必须小心，不要修改这些这些对象所依赖的状态，这是一个小陷阱。如果你需要根据对象当前的状态进行比较的话，你应该不要再重定义equals，应该起其他的方法名字而不是equals。对于我们的Point类的最后的定义，我们最好省略掉hashCode的重载，并将比较的方法名命名为equalsContents，或其他不同于equals的名字。那么Point将会继承原来默认的equals和hashCode的实现，因此当我们修改了x域后p依然会呆在其原来在容器中应该在位置。</p>

<h4 id="toc_4">陷阱4：不满足等价关系的equals错误定义</h4>

<p>Object中的equals的规范阐述了equals方法必须实现在非null对象上的等价关系：</p>

<ul>
<li>  自反原则：对于任何非null值X,表达式x.equals(x)总返回true。</li>
<li>  等价性：对于任何非空值x和y，那么当且仅当y.equals(x)返回真时，x.equals(y)返回真。</li>
<li>  传递性：对于任何非空值x,y,和z，如果x.equals(y)返回真，且y.equals(z)也返回真，那么x.equals(z)也应该返回真。</li>
<li>  一致性：对于非空x,y，多次调用x.equals(y)应该一致的返回真或假。提供给equals方法比较使用的信息不应该包含改过的信息。</li>
<li>  对于任何非空值x,x.equals(null)应该总返回false.</li>
</ul>

<p>Point类的equals定义已经被开发成了足够满足equals规范的定义。然而，当考虑到继承的时候，事情就开始变得非常复杂起来。比如说有一个Point的子类ColoredPoint，它比Point多增加了一个类型是Color的color域。假设Color被定义为一个枚举类型：</p>

<pre><code>public enum Color {
    RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET;
}
</code></pre>

<p>ColoredPoint重载了equals方法，并考虑到新加入color域，代码如下：</p>

<pre><code>public class ColoredPoint extends Point { // Problem: equals not symmetric

    private final Color color;

    public ColoredPoint(int x, int y, Color color) {
        super(x, y);
        this.color = color;
    }

    @Override public boolean equals(Object other) {
        boolean result = false;
        if (other instanceof ColoredPoint) {
            ColoredPoint that = (ColoredPoint) other;
            result = (this.color.equals(that.color) &amp;&amp; super.equals(that));
        }
        return result;
    }
}
</code></pre>

<p>这是很多程序员都有可能写成的代码。注意在本例中，类ColoredPointed不需要重载hashCode，因为新的ColoredPoint类上的equals定义，严格的重载了Point上equals的定义。hashCode的规范仍然是有效，如果两个着色点(colored point)相等，其坐标必定相等，因此它的hashCode也保证了具有同样的值。</p>

<p>对于ColoredPoint类自身对象的比较是没有问题的，但是如果使用ColoredPoint和Point混合进行比较就要出现问题。</p>

<pre><code>Point p = new Point(1, 2);

ColoredPoint cp = new ColoredPoint(1, 2, Color.RED);

System.out.println(p.equals(cp)); // 打印真 true

System.out.println(cp.equals(p)); // 打印假 false
</code></pre>

<p>“p等价于cp”的比较这个调用的是定义在Point类上的equals方法。这个方法只考虑两个点的坐标。因此比较返回真。在另外一方面，“cp等价于p”的比较这个调用的是定义在ColoredPoint类上的equals方法，返回的结果却是false，这是因为p不是ColoredPoint，所以equals这个定义违背了对称性。</p>

<p>违背对称性对于集合来说将导致不可以预期的后果，例如：</p>

<pre><code>Set&lt;Point&gt; hashSet1 = new java.util.HashSet&lt;Point&gt;();
hashSet1.add(p);
System.out.println(hashSet1.contains(cp));    // 打印 false

Set&lt;Point&gt; hashSet2 = new java.util.HashSet&lt;Point&gt;();
hashSet2.add(cp);
System.out.println(hashSet2.contains(p));    // 打印 true
</code></pre>

<p>因此虽然p和cp是等价的，但是contains测试中一个返回成功，另外一个却返回失败。</p>

<p>你如何修改equals的定义，才能使得这个方法满足对称性？本质上说有两种方法，你可以使得这种关系变得更一般化或更严格。更一般化的意思是这一对对象，a和b，被用于进行对比，无论是a比b还是b比a 都返回true，下面是代码：</p>

<pre><code>public class ColoredPoint extends Point { // Problem: equals not transitive

    private final Color color;

    public ColoredPoint(int x, int y, Color color) {
        super(x, y);
        this.color = color;
    }

    @Override public boolean equals(Object other) {
        boolean result = false;
        if (other instanceof ColoredPoint) {
            ColoredPoint that = (ColoredPoint) other;
            result = (this.color.equals(that.color) &amp;&amp; super.equals(that));
        }
        else if (other instanceof Point) {
            Point that = (Point) other;
            result = that.equals(this);
        }
        return result;
    }
}
</code></pre>

<p>在ColoredPoint中的equals的新定义比老定义中检查了更多的情况:如果对象是一个Point对象而不是ColoredPoint，方法就转变为Point类的equals方法调用。这个所希望达到的效果就是equals的对称性，不管”cp.equals(p)”还是”p.equals(cp)”的结果都是true。然而这种方法，equals的规范还是被破坏了，现在的问题是这个新等价性不满足传递性。考虑下面的一段代码实例，定义了一个点和这个点上上两种不同颜色点：</p>

<pre><code>ColoredPoint redP = new ColoredPoint(1, 2, Color.RED);
ColoredPoint blueP = new ColoredPoint(1, 2, Color.BLUE);
</code></pre>

<p>redP等价于p，p等价于blueP</p>

<pre><code>System.out.println(redP.equals(p)); // prints true

System.out.println(p.equals(blueP)); // prints true
</code></pre>

<p>然而，对比redP和blueP的结果是false:</p>

<pre><code>System.out.println(redP.equals(blueP)); // 打印 false
</code></pre>

<p>因此，equals的传递性就被违背了。</p>

<p>使equals的关系更一般化似乎会将我们带入到死胡同。我们应该采用更严格化的方法。一种更严格化的equals方法是认为不同类的对象是不同的。这个可以通过修改Point类和ColoredPoint类的equals方法来达到。你能增加额外的比较来检查是否运行态的这个Point类和那个Point类是同一个类，就像如下所示的代码一样：</p>

<pre><code>// A technically valid, but unsatisfying, equals method
public class Point {

    private final int x;
    private final int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    @Override public boolean equals(Object other) {
        boolean result = false;
        if (other instanceof Point) {
            Point that = (Point) other;
            result = (this.getX() == that.getX() &amp;&amp; this.getY() == that.getY()
                    &amp;&amp; this.getClass().equals(that.getClass()));
        }
        return result;
    }

    @Override public int hashCode() {
        return (41 * (41 + getX()) + getY());
    }
}
</code></pre>

<p>你现在可以将ColoredPoint类的equals实现用回刚才那个不满足对称性要的equals实现了。</p>

<pre><code>public class ColoredPoint extends Point { // 不再违反对称性需求

    private final Color color;

    public ColoredPoint(int x, int y, Color color) {
        super(x, y);
        this.color = color;
    }

    @Override public boolean equals(Object other) {
        boolean result = false;
        if (other instanceof ColoredPoint) {
            ColoredPoint that = (ColoredPoint) other;
            result = (this.color.equals(that.color) &amp;&amp; super.equals(that));
        }
        return result;
    }
}
</code></pre>

<p>这里，Point类的实例只有当和另外一个对象是同样类，并且有同样的坐标时候，他们才被认为是相等的，即意味着 .getClass()返回的是同样的值。这个新定义的等价关系满足了对称性和传递性因为对于比较对象是不同的类时结果总是false。所以着色点(colored point)永远不会等于点(point)。通常这看起来非常合理，但是这里也存在着另外一种争论——这样的比较过于严格了。</p>

<p>考虑我们如下这种稍微的迂回的方式来定义我们的坐标点(1,2)</p>

<pre><code>Point pAnon = new Point(1, 1) {
    @Override public int getY() {
        return 2;
    }
};
</code></pre>

<p>pAnon等于p吗？答案是假，因为p和pAnon的java.lang.Class对象不同。p是Point，而pAnon是Point的一个匿名派生类。但是，非常清晰的是pAnon的确是在坐标1，2上的另外一个点。所以将他们认为是不同的点是没有理由的。</p>

<h4 id="toc_5">canEqual 方法</h4>

<p>到此，我们看其来似乎是遇到阻碍了，存在着一种正常的方式不仅可以在不同类继承层次上定义等价性，并且保证其等价的规范性吗？事实上，的确存在这样的一种方法，但是这就要求除了重定义equals和hashCode外还要另外的定义一个方法。基本思路就是在重载equals(和hashCode)的同时，它应该也要要明确的声明这个类的对象永远不等价于其他的实现了不同等价方法的超类的对象。为了达到这个目标，我们对每一个重载了equals的类新增一个方法canEqual方法。这个方法的方法签名是：</p>

<pre><code>public boolean canEqual(Object other)
</code></pre>

<p>如果other 对象是canEquals(重)定义那个类的实例时，那么这个方法应该返回真，否则返回false。这个方法由equals方法调用，并保证了两个对象是可以相互比较的。下面Point类的新的也是最终的实现：</p>

<pre><code>public class Point {

    private final int x;
    private final int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    @Override public boolean equals(Object other) {
        boolean result = false;
        if (other instanceof Point) {
            Point that = (Point) other;
            result =(that.canEqual(this) &amp;&amp; this.getX() == that.getX() &amp;&amp; this.getY() == that.getY());
        }
        return result;
    }

    @Override public int hashCode() {
        return (41 * (41 + getX()) + getY());
    }
    public boolean canEqual(Object other) {
        return (other instanceof Point);
    }

}
</code></pre>

<p>这个版本的Point类的equals方法中包含了一个额外的需求，通过canEquals方法来决定另外一个对象是否是是满足可以比较的对象。在Point中的canEqual宣称了所有的Point类实例都能被比较。</p>

<p>下面是ColoredPoint相应的实现</p>

<pre><code>public class ColoredPoint extends Point { // 不再违背对称性

    private final Color color;

    public ColoredPoint(int x, int y, Color color) {
        super(x, y);
        this.color = color;
    }

    @Override public boolean equals(Object other) {
        boolean result = false;
        if (other instanceof ColoredPoint) {
            ColoredPoint that = (ColoredPoint) other;
            result = (that.canEqual(this) &amp;&amp; this.color.equals(that.color) &amp;&amp; super.equals(that));
        }
        return result;
    }

    @Override public int hashCode() {
        return (41 * super.hashCode() + color.hashCode());
    }

    @Override public boolean canEqual(Object other) {
        return (other instanceof ColoredPoint);
    }
}
</code></pre>

<p>在上显示的新版本的Point类和ColoredPoint类定义保证了等价的规范。等价是对称和可传递的。比较一个Point和ColoredPoint类总是返回false。因为点p和着色点cp,“p.equals(cp)返回的是假。并且，因为cp.canEqual(p)总返回false。相反的比较，cp.equals(p)同样也返回false，由于p不是一个ColoredPoint，所以在ColoredPoint的equals方法体内的第一个instanceof检查就失败了。</p>

<p>另外一个方面，不同的Point子类的实例却是可以比较的，同样没有重定义等价性方法的类也是可以比较的。对于这个新类的定义，p和pAnon的比较将总返回true。下面是一些例子：</p>

<pre><code>Point p = new Point(1, 2);

ColoredPoint cp = new ColoredPoint(1, 2, Color.INDIGO);

Point pAnon = new Point(1, 1) {
    @Override public int getY() {
        return 2;
    }
};

Set&lt;Point&gt; coll = new java.util.HashSet&lt;Point&gt;();
coll.add(p);

System.out.println(coll.contains(p)); // 打印 true

System.out.println(coll.contains(cp)); // 打印 false

System.out.println(coll.contains(pAnon)); // 打印 true
</code></pre>

<p>这些例子显示了如果父类在equals的实现定义并调用了canEquals，那么开发人员实现的子类就能决定这个子类是否可以和它父类的实例进行比较。例如ColoredPoint，因为它以”一个着色点永远不可以等于普通不带颜色的点重载了” canEqual，所以他们就不能比较。但是因为pAnon引用的匿名子类没有重载canEqual,因此它的实例就可以和Point的实例进行对比。</p>

<p>canEqual方法的一个潜在的争论是它是否违背了Liskov替换准则(LSP)。例如，通过比较运行态的类来实现的比较技术(<strong>译者注：</strong> canEqual的前一版本，使用.getClass()的那个版本)，将导致不能定义出一个子类，这个子类的实例可以和其父类进行比较，因此就违背了LSP。这是因为，LSP原则是这样的，在任何你能使用父类的地方你都可以使用子类去替换它。在之前例子中，虽然cp的x,y坐标匹配那些在集合中的点，然而”coll.contains(cp)”仍然返回false，这看起来似乎违背得了LSP准则，因为你不能这里能使用Point的地方使用一个ColoredPointed。但是我们认为这种解释是错误的，因为LSP原则并没有要求子类和父类的行为一致，而仅要求其行为能一种方式满足父类的规范。</p>

<p>通过比较运行态的类来编写equals方法(<strong>译者注：</strong> canEqual的前一版本，使用.getClass()的那个版本)的问题并不是违背LSP准则的问题，但是它也没有为你指明一种创建派生类的实例能和父类实例进行对比的的方法。例如，我们使用这种运行态比较的技术在之前的”coll.contains(pAnon)”将会返回false，并且这并不是我们希望的。相反我们希望“coll.contains(cp)”返回false，因为通过在ColoredPoint中重载的equals，我基本上可以说，一个在坐标1，2上着色点和一个坐标1，2上的普通点并不是一回事。然而，在最后的例子中，我们能传递Point两种不同的子类实例到集合中contains方法，并且我们能得到两个不同的答案，并且这两个答案都正确。</p>

<p><strong>–全文完–</strong></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/9/5</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android%E5%BC%80%E5%8F%91.html'>Android开发</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14720509840810.html">
                
                  <h1>Android GPS定位欺骗(模拟定位)的两种方式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>前段时间发布的手游PokemonGo相信大家都有耳闻，而因为这个游戏在国内的坐标遭到了封锁，很多科学游戏方法也陆续涌现。好不热闹。<br/>
那其实，PokemonGo最初的版本，在大陆是可以通过简单的vpn+gps欺骗进行游戏的。<br/>
不过很快地，在新的版本更新中就封锁了这一方式。</p>

<p>而对Android系统使用GPS欺骗，应用场景也绝不只是这一个游戏而已。所以我今天来简单介绍一下可使用的几种方式。</p>

<blockquote>
<p>控制噪声的方式有三种：防止噪声产生，阻断噪声传播和防止噪声进入耳朵</p>
</blockquote>

<p>相对应的，</p>

<blockquote>
<p>修改GPS定位结果的三种途径： 编译时修改NLP结果，运行时修改LocationManager结果，从应用获取到的结果修改。</p>
</blockquote>

<h3 id="toc_0">1. 编译时修改NLP结果</h3>

<p>难度系数：五颗星<br/>
建议：想都别想<br/>
大概思路：修改nlp部分源码，重编系统</p>

<h3 id="toc_1">2. 运行时修改LocationManager结果</h3>

<p>这个分两类：</p>

<blockquote>
<p><strong>一类</strong>： 使用android自带的调试api，模拟gps provider的结果。</p>
</blockquote>

<pre><code>LocationManager.setTestProviderLocation(Provider, Location);
</code></pre>

<p>优点：简单，无需root<br/>
缺点：不稳定，特征明显，容易按特征嗅探到（有反作弊机制的游戏基本都能查出来），需要打开开发者的允许模拟位置选项</p>

<blockquote>
<p><strong>第二类</strong>: 使用xposed,传说中的android神器，用它对app_process进行注入。</p>
</blockquote>

<p>有什么用呢，就是你可以放个钩子，英文名叫hook。这个钩子能知道你系统里的每个应用什么时候调用了哪个函数，还能修改对应的这个函数。<br/>
说到这就懂了吧。比如你猜测对应app会使用LocationManager.getLastKnownLocation的结果。然后你用xposed把内存里的这个函数返回值改成 <code>纬度 N 39.832670° 东经 E116.460370°</code>，然后调用这个函数的程序看到的记过就是你修改之后的结果。<br/>
具体代码看这里吧（非本人repo，只是找了个简单易懂的demo）<br/>
<a href="https://github.com/YiuChoi/FakeGps/tree/master/app/src/main/java/name/caiyao/fakegps/hook">FakeGPS demo</a></p>

<p>优点：稳定，难以被反查<br/>
缺点：需要root</p>

<h3 id="toc_2">3. 对想欺骗的app反编译，修改结果</h3>

<p>该怎么做看标题就明白了。<br/>
步骤就是<br/>
1. 反编译<br/>
2. 找到所有使用了定位结果的位置<br/>
3. 修改结果<br/>
4. 重新打包</p>

<p>这个方式的优缺点也很明显。<br/>
优点： 无需root，稳定性强（前提是找准入口）<br/>
缺点： 技术水平要求高。根据应用复杂程度、混淆、安全策略等不同，难度差异较大。难易程度包括很多内容，包括混淆部分、入口寻找、签名验证等。 我也不熟啊，感兴趣的同学请自行深入学习吧。</p>

<p>————————</p>

<p>3类4种欺骗方式，各位看官收好。</p>

<p>以上。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/8/24</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android%E5%BC%80%E5%8F%91.html'>Android开发</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14720509627845.html">
                
                  <h1>android - LinearLayout RelativeLayout在布局时优先选择谁？有何区别？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>很多初接触android的同学在布局时都会有这样一个疑问：</p>

<blockquote>
<p>这个布局的父亲用LinearLayout和RelativeLayout都可以，我用哪个更合适呢？</p>
</blockquote>

<p>有些同学可能就开始权量了，RelativeLayout更灵活，用这个吧。但是感觉LinearLayout更方便啊，自动帮我把这几个View分布开了，不会一开始就挤在一块。</p>

<p>其实呢，随着项目的进展，布局会发生调整，这是再自然不过的事情。</p>

<blockquote>
<p>不要让自己这些『主观』的思考拖慢进度。</p>
</blockquote>

<p>今天我从数据上来说下在面临这种情况（两者都可选择）时，应如何选择。</p>

<p><strong>注: 当然，很多情况会有其它更好的选择，我这里仅就这两者进行对比。</strong></p>

<blockquote>
<p>从效率的角度考虑，选取渲染速度更快的那个。</p>
</blockquote>

<p>我们知道一个View的绘制包括三个步骤：<br/>
1. 测量 measure<br/>
2. 布局 layout<br/>
3. 绘制 draw</p>

<p>这三个哪个拖后腿都会影响渲染效率，我们就来看看使用不同的布局时，这三者之间的差距。</p>

<table>
<thead>
<tr>
<th></th>
<th>子View</th>
<th>父View</th>
</tr>
</thead>

<tbody>
<tr>
<td>父View使用LinearLayout</td>
<td><img src="http://upload-images.jianshu.io/upload_images/25769-ad4a99485588a741.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="linear_child.png"/></td>
<td><img src="http://upload-images.jianshu.io/upload_images/25769-c2a9998a2d24bc74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="linear_parent.png"/></td>
</tr>
<tr>
<td>父View使用RelativeLayout</td>
<td><img src="http://upload-images.jianshu.io/upload_images/25769-0d2ff6157d6133e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="relative_child.png"/></td>
<td><img src="http://upload-images.jianshu.io/upload_images/25769-4c1f5807cd35172d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="relative_parent.png"/></td>
</tr>
</tbody>
</table>

<p>这里我们主要关注 <strong>Measure</strong> 时间。<br/>
通过对比我们可以看到，父View使用LinearLayout时，父亲和孩子的Measure时间是相差无几的。<br/>
而父View使用RelativeLayout时，父亲几乎是孩子的两倍。</p>

<blockquote>
<p>RelativeLayout 的子View经常会被measure两次。</p>
</blockquote>

<h3 id="toc_0">结论</h3>

<ol>
<li>两者都可使用，并且层数不受影响的前提下，尽量使用LinearLayout.</li>
<li>若是层数受影响，优先考虑层数少的。(这点会在以后的文章中谈到)</li>
</ol>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/8/24</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android%E5%BC%80%E5%8F%91.html'>Android开发</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14720508913010.html">
                
                  <h1>带阴影的TextView 淡入淡出动画异常，显示多余的阴影</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4 id="toc_0">1. 问题</h4>

<p>带阴影的TextView 淡入淡出动画异常，有多余的阴影</p>

<h4 id="toc_1">2. 复现步骤</h4>

<ol>
<li>TextView 设置阴影</li>
<li>对TextView设置的alpha值设置 ObjectAnimator</li>
<li>观察</li>
</ol>

<h4 id="toc_2">3. 上图</h4>

<table>
<thead>
<tr>
<th>TextView底部有多余阴影</th>
<th>动画正常</th>
</tr>
</thead>

<tbody>
<tr>
<td><img src="http://upload-images.jianshu.io/upload_images/25769-6ba639edeab70edb.jpg?imageMogr2/auto-orient/strip" alt=""/></td>
<td><img src="http://upload-images.jianshu.io/upload_images/25769-57053d376b7c5fd8.jpg?imageMogr2/auto-orient/strip" alt=""/></td>
</tr>
</tbody>
</table>

<h4 id="toc_3">4. 原因</h4>

<ol>
<li>硬件加速并非对所有2D图形的支持都很好，处理alpha相关的事件时需尤为注意。</li>
<li>并非所有方法都有做应对处理。</li>
</ol>

<h4 id="toc_4">5. 解决方案</h4>

<ol>
<li>对相应的View或Activity或Application关闭硬件加速。</li>
<li>使用其他替代方法实现动画。这就要看具体方法的实现了。</li>
</ol>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/8/24</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android%E5%BC%80%E5%8F%91.html'>Android开发</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14701507519730.html">
                
                  <h1>Android应用横竖屏切换的两种方式，从表现上看最大的区别</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>我们知道android应用更改屏幕方向有两种方式，对应两种过程，一是销毁重建，二是设置onConfigurationChanged。在其中做改变方向的处理。</p>

<p>很久前我们的测试同学给计算器应用报了一个bug，说应用旋转到横屏后锁屏，再解锁。此时应用会先回到竖屏，再转换到横屏(图一)。正确的表现应该和浏览器的表现一样(图二),解锁后直接进入横屏。<br/>
<img src="http://i.imgur.com/m9kqNuh.gif" alt="图一，表现错误，使用销毁重建的方式"/><br/>
<img src="http://i.imgur.com/jsswjwK.gif" alt="图二，表现正确，使用onConfigurationChanged"/></p>

<p>百思不得其解。<br/>
后来解一个性能相关的bug，很巧地把原来销毁重建的方式，改成了onConfigurationChanged处理。无意间解了这个搁置很久的问题。</p>

<p>根据systrace的结果，推测可能的原因如下。<br/>
1. 销毁重建，其间会进行目标activity的销毁、重建以及其它系统调用。这一系列动作不能在一帧内完成，导致解锁时能看到竖屏切换到横屏的动作。<br/>
2. onConfigurationChanged，横竖屏切换其间只执行这一个函数，其中只有layout的MLD操作，这一系列动作在短时间内完成，因此我们看到的也就直接进入和横屏。<br/>
3. 可能有其它activity管理之间的原因，暂不清楚。知道的请不吝赐教。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/8/2</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android%E5%BC%80%E5%8F%91.html'>Android开发</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14685051740290.html">
                
                  <h1>PokemonGo破解</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ol>
<li>简单的更改unity位置
报错
<code>07-14 22:04:02.801 7512-9260/? E/NianticAccountManager: User cannot be authenticated.
                                                    com.google.android.gms.auth.GoogleAuthException: INVALID_AUDIENCE
                                                        at com.google.android.gms.auth.GoogleAuthUtil.zza(Unknown Source)
                                                        at com.google.android.gms.auth.GoogleAuthUtil.getToken(Unknown Source)
                                                        at com.google.android.gms.auth.GoogleAuthUtil.getToken(Unknown Source)
                                                        at com.google.android.gms.auth.GoogleAuthUtil.getToken(Unknown Source)
                                                        at com.nianticlabs.nia.account.NianticAccountManager.getAccount(NianticAccountManager.java:75)</code></li>
</ol>

<h2 id="toc_0">测试一下是否有签名登录保护之类的策略。</h2>

<p>使用apk反编译后直接重新打包，打开app。<br/>
google账号鉴权成功。没问题！</p>

<h2 id="toc_1">测试做些简单的修改</h2>

<p><code>    invoke-virtual {p0, v0}, Lcom/kodelabs/boilerplate/presentation/ui/activities/MainActivity;-&gt;updateLocation(Landroid/location/Location;)V</code><br/>
<code><br/>
.method public updateLocation(Landroid/location/Location;)V<br/>
    .locals 2<br/>
    .param p1, &quot;location&quot;    # Landroid/location/Location;</p>

<pre><code>.prologue
.line 31
const-wide v0, -0x3fa7170e2c12ad82L    # -99.63976

invoke-virtual {p1, v0, v1}, Landroid/location/Location;-&gt;setLongitude(D)V

.line 32
const-wide v0, 0x4043d0087ca643ccL    # 39.625259

invoke-virtual {p1, v0, v1}, Landroid/location/Location;-&gt;setLatitude(D)V

.line 33
return-void
</code></pre>

<p>.end method</code></p>

<h2 id="toc_2">打包安装</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/7/14</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android%E5%BC%80%E5%8F%91.html'>Android开发</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14583860309318.html">
                
                  <h1>Creating a Navigation Drawer</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">表现</h2>

<p>Navigation Drawer <br/>
<img src="media/14583860309318/14583864312339.jpg" alt=""/></p>

<p>手指从屏幕左边右滑，打开的这个像 Menu 一样的的页面就被称为 NavigationDrawer。<br/>
谷歌在 MD 规范中详细说明了它的设计规范，在开始设计你的应用时请务必阅读作为参考。<br/>
<a href="http://developer.android.com/design/patterns/navigation-drawer.html">Navigation Drawer</a></p>

<h2 id="toc_1">实现思路</h2>

<p>分析一下，很容易看出来，基本是分为两层。上层的这个 Drawer 层(包含你看到的这个 View 和可能被忽略的覆盖下层的阴影)，下层的包含了页面本身的内容层(ActionBar TabLayout 其它内容)。</p>

<h2 id="toc_2">使用方式</h2>

<p>所以，使用也很符合思考模式：以 DrawerLayout 为根 View 包含两层子 View。</p>

<h3 id="toc_3">1. XML 文件</h3>

<pre><code class="language-&lt;android.support.v4.widget.DrawerLayout">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:id=&quot;@+id/drawer_layout&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;
    &lt;!-- The main content view --&gt;
    &lt;FrameLayout
        android:id=&quot;@+id/content_frame&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot; /&gt;
    &lt;!-- The navigation drawer --&gt;
    &lt;ListView android:id=&quot;@+id/left_drawer&quot;
        android:layout_width=&quot;240dp&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_gravity=&quot;start&quot;
        android:choiceMode=&quot;singleChoice&quot;
        android:divider=&quot;@android:color/transparent&quot;
        android:dividerHeight=&quot;0dp&quot;
        android:background=&quot;#111&quot;/&gt;
&lt;/android.support.v4.widget.DrawerLayout&gt;
</code></pre>

<p><strong>注意的点</strong><br/>
*  内容层必须是DrawerLayout 的第一个子 View。因为 XML 以 View 的顺序决定 Z 的次序。<br/>
*  drawer 层必须设定 android:layout_gravity 属性。用来支持 right-to-left 语言。注意用 &quot;start&quot; 代替 &quot;left&quot;。<br/>
*  drawer 层的宽度小于320dp，这样展开时也能看到下方的内容。高度 match_parent。</p>

<h3 id="toc_4">2. 代码对内容进行配置</h3>

<pre><code>public class MainActivity extends Activity {
    private String[] mPlanetTitles;
    private DrawerLayout mDrawerLayout;
    private ListView mDrawerList;
    ...

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        mPlanetTitles = getResources().getStringArray(R.array.planets_array);
        mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout);
        mDrawerList = (ListView) findViewById(R.id.left_drawer);

        // Set the adapter for the list view
        mDrawerList.setAdapter(new ArrayAdapter&lt;String&gt;(this,
                R.layout.drawer_list_item, mPlanetTitles));
        // Set the list&#39;s click listener
        mDrawerList.setOnItemClickListener(new DrawerItemClickListener());

        ...
    }
}
</code></pre>

<h3 id="toc_5">3. 处理其它问题</h3>

<h4 id="toc_6">3.1 处理点击事件导航</h4>

<p>给 Drawer 的 ListView 设置 OnItemClickListener 就行。<br/>
<strong>示例代码</strong><br/>
```<br/>
private class DrawerItemClickListener implements ListView.OnItemClickListener {<br/>
    @Override<br/>
    public void onItemClick(AdapterView parent, View view, int position, long id) {<br/>
        selectItem(position);<br/>
    }<br/>
}</p>

<p>/** Swaps fragments in the main content view */<br/>
private void selectItem(int position) {<br/>
    // Create a new fragment and specify the planet to show based on position<br/>
    Fragment fragment = new PlanetFragment();<br/>
    Bundle args = new Bundle();<br/>
    args.putInt(PlanetFragment.ARG_PLANET_NUMBER, position);<br/>
    fragment.setArguments(args);</p>

<pre><code>// Insert the fragment by replacing any existing fragment
FragmentManager fragmentManager = getFragmentManager();
fragmentManager.beginTransaction()
               .replace(R.id.content_frame, fragment)
               .commit();

// Highlight the selected item, update the title, and close the drawer
mDrawerList.setItemChecked(position, true);
setTitle(mPlanetTitles[position]);
mDrawerLayout.closeDrawer(mDrawerList);
</code></pre>

<p>}</p>

<p>@Override<br/>
public void setTitle(CharSequence title) {<br/>
    mTitle = title;<br/>
    getActionBar().setTitle(mTitle);<br/>
}<br/>
```</p>

<h4 id="toc_7">监听 Drawer 展开、关闭事件</h4>

<p>调用 DrawerLayout.setDrawerListener() 方法，传递一个 DrawerLayout.DrawerListener 接口的实现。<br/>
实现这个接口有两种方式。<br/>
1. 直接实现 DrawerListener.<br/>
2. 写一个继承 ActionBarDrawerToggle 的子类，这个类实现了这个接口，你可以在子类中重写 DrawerListener 接口函数。</p>

<p><strong>示例代码</strong><br/>
```<br/>
public class MainActivity extends Activity {<br/>
    private DrawerLayout mDrawerLayout;<br/>
    private ActionBarDrawerToggle mDrawerToggle;<br/>
    private CharSequence mDrawerTitle;<br/>
    private CharSequence mTitle;<br/>
    ...</p>

<pre><code>@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    ...

    mTitle = mDrawerTitle = getTitle();
    mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout);
    mDrawerToggle = new ActionBarDrawerToggle(this, mDrawerLayout,
            R.drawable.ic_drawer, R.string.drawer_open, R.string.drawer_close) {

        /** Called when a drawer has settled in a completely closed state. */
        public void onDrawerClosed(View view) {
            super.onDrawerClosed(view);
            getActionBar().setTitle(mTitle);
            invalidateOptionsMenu(); // creates call to onPrepareOptionsMenu()
        }

        /** Called when a drawer has settled in a completely open state. */
        public void onDrawerOpened(View drawerView) {
            super.onDrawerOpened(drawerView);
            getActionBar().setTitle(mDrawerTitle);
            invalidateOptionsMenu(); // creates call to onPrepareOptionsMenu()
        }
    };

    // Set the drawer toggle as the DrawerListener
    mDrawerLayout.setDrawerListener(mDrawerToggle);
}

/* Called whenever we call invalidateOptionsMenu() */
@Override
public boolean onPrepareOptionsMenu(Menu menu) {
    // If the nav drawer is open, hide action items related to the content view
    boolean drawerOpen = mDrawerLayout.isDrawerOpen(mDrawerList);
    menu.findItem(R.id.action_websearch).setVisible(!drawerOpen);
    return super.onPrepareOptionsMenu(menu);
}
</code></pre>

<p>}<br/>
```</p>

<h4 id="toc_8">通过 App Icon 打开、关闭 Drawer</h4>

<p>通过使用 ActionBarDrawerToggle 类，可以控制这些行为。<br/>
* 点击控制 Drawer 行为<br/>
* 指定展开时的 icon</p>

<p>标准的导航 Icon 图标在 (Download the Action Bar Icon Pack)[<a href="http://developer.android.com/downloads/design/Android_Design_Icons_20130926.zip">http://developer.android.com/downloads/design/Android_Design_Icons_20130926.zip</a>]</p>

<p>最后你需要在 Activity 的生命周期中使用 ActionBarDrawerToggle 的这些方法。<br/>
<strong>示例代码</strong><br/>
```<br/>
public class MainActivity extends Activity {<br/>
    private DrawerLayout mDrawerLayout;<br/>
    private ActionBarDrawerToggle mDrawerToggle;<br/>
    ...</p>

<pre><code>public void onCreate(Bundle savedInstanceState) {
    ...

    mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout);
    mDrawerToggle = new ActionBarDrawerToggle(
            this,                  /* host Activity */
            mDrawerLayout,         /* DrawerLayout object */
            R.drawable.ic_drawer,  /* nav drawer icon to replace &#39;Up&#39; caret */
            R.string.drawer_open,  /* &quot;open drawer&quot; description */
            R.string.drawer_close  /* &quot;close drawer&quot; description */
            ) {

        /** Called when a drawer has settled in a completely closed state. */
        public void onDrawerClosed(View view) {
            super.onDrawerClosed(view);
            getActionBar().setTitle(mTitle);
        }

        /** Called when a drawer has settled in a completely open state. */
        public void onDrawerOpened(View drawerView) {
            super.onDrawerOpened(drawerView);
            getActionBar().setTitle(mDrawerTitle);
        }
    };

    // Set the drawer toggle as the DrawerListener
    mDrawerLayout.setDrawerListener(mDrawerToggle);

    getActionBar().setDisplayHomeAsUpEnabled(true);
    getActionBar().setHomeButtonEnabled(true);
}

@Override
protected void onPostCreate(Bundle savedInstanceState) {
    super.onPostCreate(savedInstanceState);
    // Sync the toggle state after onRestoreInstanceState has occurred.
    mDrawerToggle.syncState();
}

@Override
public void onConfigurationChanged(Configuration newConfig) {
    super.onConfigurationChanged(newConfig);
    mDrawerToggle.onConfigurationChanged(newConfig);
}

@Override
public boolean onOptionsItemSelected(MenuItem item) {
    // Pass the event to ActionBarDrawerToggle, if it returns
    // true, then it has handled the app icon touch event
    if (mDrawerToggle.onOptionsItemSelected(item)) {
      return true;
    }
    // Handle your other action bar items...

    return super.onOptionsItemSelected(item);
}
...
</code></pre>

<p>}<br/>
```</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/3/19</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android%E5%BC%80%E5%8F%91.html'>Android开发</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14539061256073.html">
                
                  <h1>Smartoo 开发中遇到的问题和解决</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><code>Weibo客户端sso认证不成功</code><br/>
uri mismatch 的问题是因为weibo开放平台配置有延迟，在平台上修改redirect uri后，隔天就可以通过了<br/>
闪退的问题，可能是由于不是打的release的包，做reader的分享时就有这样的问题。明天用release的包测试一下。<br/>
使用web验证可以顺利通过。</p>

<p><code>未通过审核帐号的接口调用限制</code><br/>
大概在200-300次之间</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/1/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android%E5%BC%80%E5%8F%91.html'>Android开发</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>博客未命名</h1>
                <div class="site-des">专注于重成文思路清晰的技术文章。</div>
                <div class="social">









<a target="_blank" class="github" target="_blank" href="http://github.com/auv1107" title="GitHub">GitHub</a>

  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="%E7%94%9F%E6%B4%BB%E6%97%A5%E5%B8%B8.html"><strong>生活日常</strong></a>
        
            <a href="%E7%BB%98%E7%94%BB.html"><strong>绘画</strong></a>
        
            <a href="Android%E5%BC%80%E5%8F%91.html"><strong>Android开发</strong></a>
        
            <a href="%E4%BA%A7%E5%93%81%E6%83%B3%E6%B3%95.html"><strong>产品想法</strong></a>
        
            <a href="%E5%90%89%E5%AE%83%E5%AD%A6%E4%B9%A0%F0%9F%8E%B8.html"><strong>吉它学习🎸</strong></a>
        
            <a href="web%E5%BC%80%E5%8F%91.html"><strong>web开发</strong></a>
        
            <a href="%E4%B9%A6%E7%B1%8D%E7%94%B5%E5%BD%B1.html"><strong>书籍电影</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="14875026448350.html">金克丝动态线稿</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14875024153456.html">真人改漫画</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14870798001565.html"></a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14864295694789.html">第二张默画</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14864293409117.html">哥特绅士</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?84fca9a2f5023159ce7f5a699c8bf2d0";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


  </body>
</html>
