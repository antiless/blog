<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[博客未命名]]></title>
  <link href="lixindong.top/atom.xml" rel="self"/>
  <link href="lixindong.top/"/>
  <updated>2017-03-16T23:23:30+08:00</updated>
  <id>lixindong.top/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[每天早上的小剧场]]></title>
    <link href="lixindong.top/14896760685794.html"/>
    <updated>2017-03-16T22:54:28+08:00</updated>
    <id>lixindong.top/14896760685794.html</id>
    <content type="html"><![CDATA[
<p>每天早上起来看书画画，攒了几天的，一块发上来。</p>

<h3 id="toc_0">新垣结衣的今日子形象</h3>

<p><img src="http://i.imgur.com/QrGWDKH.jpg" alt=""/></p>

<h3 id="toc_1">介个，咳咳</h3>

<p><img src="http://i.imgur.com/WPFhALf.jpg" alt=""/></p>

<h3 id="toc_2">原型也是 Gakki 啊！！！</h3>

<p><img src="http://i.imgur.com/9YUYaH2.jpg" alt=""/></p>

<h3 id="toc_3">让人绝望的简笔画。认得出是 Gakki ？才怪！</h3>

<p><img src="http://i.imgur.com/EGLgrQ3.jpg" alt=""/></p>

<h3 id="toc_4">又一个大屁股金克丝</h3>

<p><img src="http://i.imgur.com/hohLehj.jpg" alt=""/></p>

<h3 id="toc_5">窗台涂鸦 墨海马</h3>

<p><img src="http://i.imgur.com/VjjtwkC.jpg" alt=""/></p>

<h3 id="toc_6">发条魔灵</h3>

<p><img src="http://i.imgur.com/3W5gzyp.jpg" alt=""/></p>

<h3 id="toc_7">第一幅漫画形式的画</h3>

<p><img src="http://i.imgur.com/DS4UBvv.jpg" alt=""/></p>

<h3 id="toc_8">盲仔。不是很爱画 man 啊。</h3>

<p><img src="http://i.imgur.com/FAyTld1.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[金克丝动态线稿]]></title>
    <link href="lixindong.top/14875026448350.html"/>
    <updated>2017-02-19T19:10:44+08:00</updated>
    <id>lixindong.top/14875026448350.html</id>
    <content type="html"><![CDATA[
<p><img src="http://i.imgur.com/AEkSJpB.jpg" alt=""/></p>

<p>大屁股金克丝。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[真人改漫画]]></title>
    <link href="lixindong.top/14875024153456.html"/>
    <updated>2017-02-19T19:06:55+08:00</updated>
    <id>lixindong.top/14875024153456.html</id>
    <content type="html"><![CDATA[
<p>阴影，衣褶，头的比例，头发分组。</p>

<p>### 赵丽颖</p>

<p> <img src="http://i.imgur.com/pBFYfRu.jpg" alt=""/> <br/>
 <img src="http://i.imgur.com/Lumpjpb.jpg" alt=""/><br/>
 <img src="http://i.imgur.com/4QaD9Re.jpg" alt=""/></p>

<p>画师说我以前用色偏暗，这个特地用了粉嫩嫩的颜色。</p>

<h3 id="toc_0">鹿晗？</h3>

<p><img src="http://i.imgur.com/XqeS9EU.jpg" alt=""/><br/>
话说一只分不清鹿晗和张艺兴来着</p>

<p><img src="http://i.imgur.com/fvLlmfZ.jpg" alt=""/><br/>
手稿</p>

<p><img src="http://i.imgur.com/x3Br7rH.jpg" alt=""/></p>

<p>衣服上exo字母颜色上残，后来直接自暴自弃了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[]]></title>
    <link href="lixindong.top/14870798001565.html"/>
    <updated>2017-02-14T21:43:20+08:00</updated>
    <id>lixindong.top/14870798001565.html</id>
    <content type="html"><![CDATA[
<h1 id="toc_0">第一张完整插画，线稿被彩铅毁了系列，lovelive 南小鸟 高坂穗乃果 小泉花阳</h1>

<p>一直知道自己对颜色感觉差，画完线稿后也告诉自己，“上色会毁了这幅画！”<br/>
然后就真的被毁了。<br/>
至少是毁了一半。<br/>
以及对不起用掉一半的褐色铅笔。<br/>
我觉得有必要买本秘密花园做些针对练习。<br/>
希望明天的马赛克练习能有所帮助。<br/>
马赛克。</p>

<hr/>

<p><img src="http://i.imgur.com/bAloLSw.jpg" alt=""/><br/>
线稿完成！<br/>
画了三个疗程，结束时心理美滋滋的。<br/>
因为作画过程中我发现，画本子比插画容易得多，以为，不用画衣服！</p>

<hr/>

<p><img src="http://i.imgur.com/URPuVY8.jpg" alt=""/><br/>
上色前天晚上简单看了下蕾姆上色教学，学到些东西。不然不知道这幅会涂成什么样子。<br/>
肯定是浅棕色涂满整张脸，蓝色均匀地上满眼球，头发没有一点光泽，发根不会加重色。</p>

<hr/>

<p><img src="http://i.imgur.com/MDmhvYU.jpg" alt=""/><br/>
 颜色上到这里我已经要崩溃了。<br/>
 左边衣服的颜色暗部部突出，找不到合适的颜色。<br/>
 中间的头发亮瞎狗眼，衣服像烤焦了的小麦面包。不但又硬又干还散发着一股令人感到酸爽的焦味。<br/>
 右边，哦，颜色简直是乱上。围巾暗部太分散了，像是天上飘的花瓣，分散视线。不过好在不是漫天飞的，夕阳。</p>

<hr/>

<p><img src="http://i.imgur.com/bsm1Tcl.jpg" alt=""/><br/>
到这个程度已经是夜里3点了。<br/>
楼房颜色，旁边路面为了方便直接画成水。<br/>
水，太浅，发白，分散视线。路面发黄，和右边人物对比度低。<br/>
左上建筑和头发明度区别小。</p>

<hr/>

<p><img src="http://i.imgur.com/shGtuwW.jpg" alt=""/></p>

<p>完工。<br/>
路面画歪了。透视太差。<br/>
左上楼房违和感很高。<br/>
我很满意。<br/>
即便颜色毁了我的线稿。<br/>
可总有一些线稿需要作为熟悉颜色的祭品。<br/>
我也，心安了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第二张默画]]></title>
    <link href="lixindong.top/14864295694789.html"/>
    <updated>2017-02-07T09:06:09+08:00</updated>
    <id>lixindong.top/14864295694789.html</id>
    <content type="html"><![CDATA[
<p>看的动漫很多，但观察过的太少。记忆中的就更千篇一律了。<br/>
默画时真是想不出能画什么头发。当然眼耳鼻口都是。</p>

<p><img src="http://i.imgur.com/sDGFD0T.jpg" alt="第二张默画"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[哥特绅士]]></title>
    <link href="lixindong.top/14864293409117.html"/>
    <updated>2017-02-07T09:02:20+08:00</updated>
    <id>lixindong.top/14864293409117.html</id>
    <content type="html"><![CDATA[
<p>第一幅木偶画的成品。</p>

<p>画师说我的画有点哥特风格，带点神秘。<br/>
我想说，其实我非常喜欢哥特，哥特萝莉知道呢撒。</p>

<p><img src="http://i.imgur.com/kuhZPnS.jpg" alt="哥特绅士"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第一张默画的脸]]></title>
    <link href="lixindong.top/14864292158339.html"/>
    <updated>2017-02-07T09:00:15+08:00</updated>
    <id>lixindong.top/14864292158339.html</id>
    <content type="html"><![CDATA[
<p>一开始想画炮姐体积巨大化后，双眼冒火怒而俯视着我的那张脸。无奈细节画不出来，画出了这张gaygay的。<br/>
<img src="http://i.imgur.com/Cxuj3aT.jpg" alt="第一张默画的脸"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[漂亮的小姐姐]]></title>
    <link href="lixindong.top/14864291268688.html"/>
    <updated>2017-02-07T08:58:46+08:00</updated>
    <id>lixindong.top/14864291268688.html</id>
    <content type="html"><![CDATA[
<p>我有一毛病。画时哪哪都觉得画的不对，画完看照片发现美呆了。可能这就是传说中的完美主义心理作祟吧。帅。</p>

<p><img src="http://i.imgur.com/ev28rlB.jpg" alt="小姐姐"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[彩铅完全不会用]]></title>
    <link href="lixindong.top/14864289816648.html"/>
    <updated>2017-02-07T08:56:21+08:00</updated>
    <id>lixindong.top/14864289816648.html</id>
    <content type="html"><![CDATA[
<p>上色时感觉怪怪的，后来看视频，用同样的方式人就能涂上，我就费老大力，结果还是涂不上。最后结论是，工欲善其事，必先利其器。<br/>
<img src="http://i.imgur.com/Jiwvwas.jpg" alt="彩铅完全不会用"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[植物速写]]></title>
    <link href="lixindong.top/14864288964571.html"/>
    <updated>2017-02-07T08:54:56+08:00</updated>
    <id>lixindong.top/14864288964571.html</id>
    <content type="html"><![CDATA[
<p>花盆用了好久来画，最后还是歪的。<br/>
最开始动手时很小气，总是把比例画小。和我性格中的某些因素相关。<br/>
<img src="http://i.imgur.com/N0vtoxs.jpg" alt="植物速写"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[静物速写2 小熊手枪和梨]]></title>
    <link href="lixindong.top/14864288430644.html"/>
    <updated>2017-02-07T08:54:03+08:00</updated>
    <id>lixindong.top/14864288430644.html</id>
    <content type="html"><![CDATA[
<p><img src="http://i.imgur.com/3KAMeuP.jpg" alt="静物速写2"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[静物速写1 圆桌和鞋]]></title>
    <link href="lixindong.top/14864287634034.html"/>
    <updated>2017-02-07T08:52:43+08:00</updated>
    <id>lixindong.top/14864287634034.html</id>
    <content type="html"><![CDATA[
<p>其实是静物慢写，画的超级慢。用了大概4个小时。<br/>
<img src="http://i.imgur.com/G8okB7l.jpg" alt="静物速写1"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[开发这个Chrome插件，更高效地翻译社区文档]]></title>
    <link href="lixindong.top/14864277119252.html"/>
    <updated>2017-02-07T08:35:11+08:00</updated>
    <id>lixindong.top/14864277119252.html</id>
    <content type="html"><![CDATA[
<p>注：本文为产品设想，没有实际的产品实现。</p>

<p>最近在看intellij 插件的文档，没有很好的中文版本。加之长期阅读英文文档时的想法和苦恼，准备开发一个chrome插件，用于辅助翻译社区文档。<br/>
本文从一个最简单的工具出发，设想了一下操作原型，四步走，如下：</p>

<blockquote>
<p>1 . 打开待翻译页面</p>
</blockquote>

<p><img src="http://upload-images.jianshu.io/upload_images/25769-84be21a810f7e35f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""/></p>

<blockquote>
<p>2 . 选取翻译段落</p>
</blockquote>

<p>选取部分文字后跳出询问是否翻译的按钮，点击进入第3步。</p>

<p><img src="http://upload-images.jianshu.io/upload_images/25769-c62534b82dc0a5ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""/></p>

<blockquote>
<p>3 . 直接修改文字 或进行标注</p>
</blockquote>

<p>第2步中选中文字部分变成一个输入框，直接进行修改。</p>

<p>当然，在进行修改时仍然显示原文，保存翻译后隐藏原文是更好的表现方案。图片只是举例说明。<br/>
<img src="http://upload-images.jianshu.io/upload_images/25769-425369bc04e063c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""/></p>

<blockquote>
<p>4 . 保存或导出</p>
</blockquote>

<p>保存或导出这里方案也有很多，简单例举几个：<br/>
* 直接保存网页(到云端、本地)。保存后打开原文链接可选择是否直接展示翻译<br/>
* 导出到本地 pdf<br/>
* 导出markdown格式</p>

<p>这里最主要的一点就是，基本保留原来的排版结构。不需要在翻译的同时操心排版之事。</p>

<p><img src="http://upload-images.jianshu.io/upload_images/25769-73276e961c2a9ea9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""/></p>

<blockquote>
<p>要点</p>
</blockquote>

<ul>
<li>保留排版</li>
<li>直接修改符合习惯</li>
<li>打开原文可展示翻译页面</li>
</ul>

<blockquote>
<p>更多feature</p>
</blockquote>

<ul>
<li>翻译建议（包括简单单词、词组翻译，通过翻译库匹配的建议，不同领域的建议）</li>
<li>云端翻译库相关feature（通过插件翻译并保存于云端，用户自定义公开与否）</li>
<li>协同翻译功能（同一页面、同一站点下）（标注、求助等）</li>
<li>专有名词关联</li>
<li>书库，文档库</li>
<li>语法分析（拿不准的句子，看看类似的翻译例句）</li>
<li>社交，这也能社交？可以。不过已经是脱离工具之外的主题了</li>
<li>一键发布到问答社区或问答版</li>
<li>众包形式（类协同模式）</li>
</ul>

<p>有兴趣的同学请私信交流。</p>

<p>————————————<br/>
<strong>9.13 更新</strong><br/>
<a href="https://translate.google.com/community?source=t-new-user#en/zh-CN/gt/completed">谷歌翻译社区</a><br/>
文章片段化处理，分割成句子，用户只需完成短句翻译<br/>
分翻译、验证两类。综合评估翻译质量。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解LayoutInflater.inflate()]]></title>
    <link href="lixindong.top/14864276588598.html"/>
    <updated>2017-02-07T08:34:18+08:00</updated>
    <id>lixindong.top/14864276588598.html</id>
    <content type="html"><![CDATA[
<p><a href="https://www.bignerdranch.com/blog/understanding-androids-layoutinflater-inflate/">原文链接：https://www.bignerdranch.com/blog/understanding-androids-layoutinflater-inflate/</a><br/>
<a href="http://blog.chengdazhi.com/index.php/110">译文链接：http://blog.chengdazhi.com/index.php/110</a></p>

<p>由于我们很容易习惯公式化的预置代码，有时我们会忽略很优雅的细节。LayoutInflater以及它在Fragment的onCreateView()中填充View的方式带给我的就是这样的感受。这个类用于将XML文件转换成相对应的ViewGroup和控件Widget。我尝试在Google官方文档与网络上其他讨论中寻找有关的说明，而后发现许多人<strong>不但不清楚LayoutInflater的inflate()方法的细节，而且甚至在误用它。</strong></p>

<p>这里的困惑很大程度上是因为Google上有关attachToRoot（也就是inflate()方法第三个参数）的文档太模糊：</p>

<blockquote>
<p>被填充的层是否应该附在root参数内部？如果是false，root参数只适用于为XML根元素View创建正确的LayoutParams的子类。</p>
</blockquote>

<p>其实意思就是：<strong>如果attachToRoot是true的话，那第一个参数的layout文件就会被填充并附加在第二个参数所指定的ViewGroup内。方法返回结合后的View，根元素是第二个参数ViewGroup。如果是false的话，第一个参数所指定的layout文件会被填充并作为View返回。这个View的根元素就是layout文件的根元素。不管是true还是false，都需要ViewGroup的LayoutParams来正确的测量与放置layout文件所产生的View对象。</strong></p>

<p>attachToRoot传入true代表layout文件填充的View会被直接添加进ViewGroup，而传入false则代表创建的View会以其他方式被添加进ViewGroup。</p>

<p>让我们就两种情况多举一些例子来更深入的理解。</p>

<h1 id="toc_0">attachToRoot是True</h1>

<p>假设我们在XML layout文件中写了一个Button并指定了宽高为match_parent。<br/>
<code><br/>
&lt;Button xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;<br/>
android:layout_width=&quot;match_parent&quot;<br/>
android:layout_height=&quot;match_parent&quot;<br/>
android:id=&quot;@+id/custom_button&quot;&gt;<br/>
&lt;/Button&gt;<br/>
</code></p>

<p>现在我们想动态地把这个按钮添加进Fragment或Activity的LinearLayout中。如果这里LinearLayout已经是一个成员变量mLinearLayout了，我们只需要通过如下代码达成目标：</p>

<pre><code>inflater.inflate(R.layout.custom_button, mLinearLayout, true);
</code></pre>

<p>我们指定了用于填充button的layout资源文件，然后我们告诉LayoutInflater我们想把button添加到mLinearLayout中。这里Button的LayoutParams种类为LinearLayout.LayoutParams。</p>

<p>下面的代码也有同样的效果。LayoutInflater的两个参数的inflate()方法自动将attachToRoot设置为true。</p>

<pre><code>inflater.inflate(R.layout.custom_button, mLinearLayout);
</code></pre>

<p>另一种在attachToRoot中传递true的情况是使用自定义View。我们看一个layout文件中根元素有<merge>标签的例子。<merge>标签标识着这个layout文件的根ViewGroup可以有多种类型。</p>

<pre><code>public class MyCustomView extends LinearLayout {
...
private void init() {
LayoutInflater inflater = LayoutInflater.from(getContext());
inflater.inflate(R.layout.view_with_merge_tag, this);
}
}
</code></pre>

<p>这就是一个很好的使用attachToRoot的例子。这个例子中layout文件没有ViewGroup作为根元素，所以我们指定我们自定义的LinearLayout作为根元素。如果layout文件有一个FrameLayout作为根元素而不是<merge>，那么FrameLayout和它的子元素都可以正常填充，而后都会被添加到LinearLayout中，LinearLayout是根ViewGroup，包含着FrameLayout和其子元素。</merge></p>

<h1 id="toc_1">attachToRoot是False</h1>

<p>我们看一下什么时候attachToRoot应该是false。在这种情况下，inflate()方法中的第一个参数所指定的View不会被添加到第二个参数所指定的ViewGroup中。</p>

<p>回忆一下刚才的例子中的Button，我们想通过layout文件添加自定义的Button至mLinearLayout中。当attachToRoot为false时，我们仍可以将Button添加到mLinearLayout中，但是这需要我们自己动手。</p>

<pre><code>Button button = (Button) inflater.inflate(R.layout.custom_button, mLinearLayout, false);
mLinearLayout.addView(button);
</code></pre>

<p>这两行代码与刚才attachToRoot为true时的一行代码等效。通过传入false，我们告诉LayoutInflater我们不暂时还想将View添加到根元素ViewGroup中，意思是我们一会儿再添加。在这个例子中，一会儿再添加就是在inflate()后调用addView()方法。</p>

<p>在将attachToRoot设置为false的例子中，由于要手动添加View进ViewGroup导致代码变多了。将Button添加到LinearLayout中还是用一行代码直接将attachToRoot设置为true简便一些。下面我们看一下什么情况下attachToRoot必须传入false。</p>

<p>每一个RecyclerView的子元素都要在attachToRoot设置为false的情况下填充。这里子View在onCreateViewHolder()中填充。</p>

<pre><code>public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
LayoutInflater inflater = LayoutInflater.from(getActivity());
View view = inflater.inflate(android.R.layout.list_item_recyclerView, parent, false);
return new ViewHolder(view);
}
</code></pre>

<p>RecyclerView负责决定什么时候展示它的子View，这个不由我们决定。在任何我们不负责将View添加进ViewGroup的情况下都应该将attachToRoot设置为false。</p>

<p>当在Fragment的onCreateView()方法中填充并返回View时，要将attachToRoot设为false。如果传入true，会抛出IllegalStateException，因为指定的子View已经有父View了。你需要指定在哪里将Fragment的View放进Activity里，而添加、移除或替换Fragment则是FragmentManager的事情。</p>

<pre><code>FragmentManager fragmentManager = getSupportFragmentManager();
Fragment fragment = fragmentManager.findFragmentById(R.id.root_viewGroup);

if (fragment == null) {
fragment = new MainFragment();
fragmentManager.beginTransaction().add(R.id.root_viewGroup, fragment).commit();
}
</code></pre>

<p>上面代码中root_viewGroup就是Activity中用于放置Fragment的容器，它会作为inflate()方法中的第二个参数被传入onCreateView()中。它也是你在inflate()方法中传入的ViewGroup。FragmentManager会将Fragment的View添加到ViewGroup中，你可不想添加两次。</p>

<pre><code>public View onCreateView(LayoutInflater inflater, ViewGroup parentViewGroup, Bundle savedInstanceState) {
View view = inflater.inflate(R.layout.fragment_layout, parentViewGroup, false);
…
return view;
}
</code></pre>

<p>问题是：如果我们不需在onCreateView()中将View添加进ViewGroup，为什么还要传入ViewGroup呢？为什么inflate()方法必须要传入根ViewGroup？</p>

<p>原因是及时不需要马上将新填充的View添加进ViewGroup，我们还是需要这个父元素的LayoutParams来在将来添加时决定View的size和position。</p>

<p>你在网上一定会遇到一些不正确的建议。有些人会建议你如果将attachToRoot设置为false的话直接将根ViewGroup传入null。但是，如果有父元素的话，还是应该传入的。</p>

<p><img src="http://upload-images.jianshu.io/upload_images/25769-f6a7daf1df51f931.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="null-root"/></p>

<p>Lint会警告你不要讲null作为root传入。你的App不会挂掉，但是可能会表现异常。当你的子View没有正确的LayoutParams时，它会自己通过<a href="http://developer.android.com/reference/android/view/ViewGroup.html#generateDefaultLayoutParams()">generateDefaultLayoutParams</a>计算。</p>

<p>你可能并不想要这些默认的LayoutParams。你在XML指定的LayoutParams会被忽略。我们可能已经指定了子View要填充父元素的宽度，但父View又wrap_content导致最终的View小很多。</p>

<p>下面是一种没有ViewGroup作为root传入inflate()方法的情况。当为AlertDialog创建自定义View时，还无法访问父元素。</p>

<pre><code>AlertDialog.Builder dialogBuilder = new AlertDialog.Builder(mContext);
View customView = inflater.inflate(R.layout.custom_alert_dialog, null);
...
dialogBuilder.setView(customView);
dialogBuilder.show();
</code></pre>

<p>在这种情况下，可以将null作为root ViewGroup传入。后来我发现AlertDialog还是会重写LayoutParams并设置各项参数为match_parent。但是，规则还是在有ViewGroup可以传入时传入它。</p>

<h1 id="toc_2">避开崩溃、异常表现与误解</h1>

<p>希望这篇文章可以帮助你在使用LayoutInflater时避开崩溃、异常表现与误解。下面整理了文章的要点：</p>

<ul>
<li>  如果可以传入ViewGroup作为根元素，那就传入它。</li>
<li>  避免将null作为根ViewGroup传入。</li>
<li>  当我们不负责将layout文件的View添加进ViewGroup时设置attachToRoot参数为false。</li>
<li>  不要在View已经被添加进ViewGroup时传入true。</li>
<li>  自定义View时很适合将attachToRoot设置为true。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[服务器作防盗链图片中转，nodejs 上手项目简明教程]]></title>
    <link href="lixindong.top/14864272317835.html"/>
    <updated>2017-02-07T08:27:11+08:00</updated>
    <id>lixindong.top/14864272317835.html</id>
    <content type="html"><![CDATA[
<p>前几天随手写的 chrome 插件遇到了防盗链问题，由于插件不能用 js iframe 的方法反防盗链，于是想用服务器做个中转。</p>

<p>记录一下上手项目的各个点，以后再用 <code>nodejs</code> 就不用到处查资料了。</p>

<p>之前没有一套特别熟悉的 web 开发框架，加上插件存储服务依赖的平台 <code>LeanCloud</code> 刚好支持部署 <code>nodejs</code> 网站，刚好拿这个小项目作为 <code>nodejs</code> 上手项目。</p>

<hr/>

<p><strong>怎么&quot;破解防盗链&quot;呢？</strong><br/>
想要破解，就得先知道目标——防盗链如何实现。<br/>
大多数站点的策略很简单: 判断<code>request</code>请求头的<code>refer</code>是否来源于本站。若不是，拒绝访问真实图片。</p>

<p>而我们知道: 请求头是来自于客户端，是可伪造的。</p>

<p><strong>思路</strong><br/>
那么，我们伪造一个正确的refer来访问不就行了?<br/>
整个业务逻辑大概像这样:  <br/>
1. 自己的服务器后台接受带目标图片<code>url</code>参数的请求<br/>
2. 伪造<code>refer</code>请求目标图片<br/>
3. 把请求到的数据作为<code>response</code>返回</p>

<p>这就起到了图片中转的作用。</p>

<h3 id="toc_0">1. 项目是什么样子</h3>

<h4 id="toc_1">1.1 接口的样子?</h4>

<ul>
<li>有一个开放接口</li>
<li>接口有一个参数，<code>api?url=http://abc.com/image.png</code>，大概长这样子</li>
<li>响应内容是反防盗链后的真实图片</li>
</ul>

<h4 id="toc_2">1.2 应该怎么做?</h4>

<ul>
<li>把服务器跑起来</li>
<li>处理 GET 请求</li>
<li>分析请求参数</li>
<li>下载原图</li>
<li>response 原图</li>
</ul>

<h3 id="toc_3">2. 学习路径(在对目标未知的前提下提出疑问)</h3>

<ol>
<li> 如何开始，建立服务器</li>
<li> 如何处理基本请求 GET POST</li>
<li> 如何下载图片并转发</li>
<li> 完成基本功能，上线</li>
<li> 优化</li>
</ol>

<h4 id="toc_4">2.1 如何开始，建立服务器</h4>

<p>主要是  <code>http.createServer().listen(port)</code> 这组方法，建立服务器、监听端口一键搞定。</p>

<pre><code>var http = require(&#39;http&#39;);
    
http.createServer(function (request, response) {
     // do things here
}).listen(8888);
    
console.log(&#39;Server running at: 8888&#39;);
</code></pre>

<h4 id="toc_5">2.2 如何处理基本请求 GET POST</h4>

<p><code>createServer</code> 回调方法的两个参数 <code>req</code> <code>res</code> 是 http <code>request</code> 和 <code>response</code> 的内容，打印一下他们的内容。</p>

<p><code>request</code> 是 <code>InComingMessage</code> 类，打印它的 <code>url</code> 字段。</p>

<pre><code>var http = require(&#39;http&#39;);
var url = require(&#39;url&#39;);
var util = require(&#39;util&#39;);
http.createServer(function(req, res){
    res.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;});
    res.end(util.inspect(url.parse(req.url, true)));
}).listen(3000);
</code></pre>

<p><strong>请求</strong><br/>
<code>http://localhost:3000/api?url=http://abc.com/image.png</code></p>

<p><strong>请求结果</strong></p>

<pre><code>Url {
  protocol: null,
  slashes: null,
  auth: null,
  host: null,
  port: null,
  hostname: null,
  hash: null,
  search: &#39;?url=http://abc.com/image.png&#39;,
  query: { url: &#39;http://abc.com/image.png&#39; },
  pathname: &#39;/api&#39;,
  path: &#39;/api?url=http://abc.com/image.png&#39;,
  href: &#39;/api?url=http://abc.com/image.png&#39; }
</code></pre>

<p><code>query</code> 字段刚好是我们想要的内容，下载这个字段对应的图片。</p>

<h4 id="toc_6">2.3 如何下载图片并转发</h4>

<p><code>request</code> 模块支持管道方法，可以和 <code>shell</code> 的管道一样理解。</p>

<p>这可以省很多事，不需要在本地存储图片，不需要处理杂七杂八的事情，甚至不需要再去了解 <code>nodejs</code> 的流。一个方法全搞定。</p>

<p>关键方法: <code>request(options).pipe(res)</code></p>

<pre>
    var options = {
      uri: imgUrl, // 这个 uri 为空时，会认为该字段不存在，报异常
      headers: {
         'Referer': referrer // 解决部分防盗链选项
      }
    };
    request(options).pipe(res);
</pre>

<h4 id="toc_7">2.4 完成基本功能，上线</h4>

<p><a href="https://github.com/auv1107/FileTransferServer/blob/master/routes/image.js">项目地址</a></p>

<p><strong>完整代码</strong></p>

<pre><code>    &#39;use strict&#39;;
    var router = require(&#39;express&#39;).Router();
    var http = require(&#39;http&#39;);
    var url = require(&#39;url&#39;);
    var util = require(&#39;util&#39;);
    var fs = require(&#39;fs&#39;);
    var callfile = require(&#39;child_process&#39;);
    var request = require(&#39;request&#39;);
    
    router.get(&#39;/&#39;, function(req, res, next) {
        var imgUrl = url.parse(req.url, true).query.url;
        console.log(url.parse(req.url,true).query); 
    
        console.log(&#39;get a request for &#39; + imgUrl);
        if (imgUrl == null || imgUrl == &quot;&quot; || imgUrl == undefined) {
            console.log(&#39;end&#39;);
            res.end();
            return;
        }
    
        var parsedUrl = url.parse(imgUrl);
        // 这里暂时使用图片服务器主机名做Referer
        var referrer = parsedUrl.protocol + &#39;//&#39; + parsedUrl.host; 
        console.log(&#39;referrer &#39; + referrer);
    
        var options = {
          uri: imgUrl,
          headers: {
             &#39;Referer&#39;: referrer
          }
        };
    
        function callback(error, response, body) {
          if (!error &amp;&amp; response.statusCode == 200) {
            console.log(&quot;type &quot; + response.headers[&#39;content-type&#39;]);
          }
          res.end(response.body);
        }
    
        // request(options, callback);
        request(options)
            .on(&#39;error&#39;, function(err) {
                console.log(err)
            })
            .pipe(res);
    });
    
    module.exports = router;
</code></pre>

<h4 id="toc_8">2.5 优化</h4>

<p>这部分主要是防盗链部分的优化。</p>

<p>单就 <code>Referer</code> 来说，使用空值和主机名都只能满足部分需求。</p>

<p>一个优化方式是组合，当一种方式不能突破即采用另一种方式。<br/>
这种方式的有点在于扩大了适用面积，并且方法对任何场景比较通用。</p>

<p>一个优化方式是接口请求参数带源引用连接。<br/>
这种方式对很多人来说不太通用，因为很多场景下并不清楚源引用连接在哪。<br/>
但是对我的插件来说非常适用，插件本身保留了源引用。因此可以很好的绕过防盗链限制。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用LeanCloud服务做一站式Chrome插件开发——Favorite Image]]></title>
    <link href="lixindong.top/14864271201285.html"/>
    <updated>2017-02-07T08:25:20+08:00</updated>
    <id>lixindong.top/14864271201285.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">0. 目录</h2>

<ol>
<li>要开发的是什么项目
1.1 想法开端
1.2 应该有什么功能?</li>
<li>开发需要解决的核心问题</li>
<li>具体解决方案
3.1 帐号系统
3.2 存储服务
3.3 使用<code>LeanEngine</code>做反防盗链中转接口
3.4 Chrome 插件实现</li>
<li>对去后端化的看法</li>
</ol>

<h2 id="toc_1">1. 要开发的是什么项目?</h2>

<p>一个Chrome插件，用来保存浏览网页时看到的喜欢的图片。</p>

<h3 id="toc_2">1.1 想法开端</h3>

<p>在 pixiv 翻图时看到一些喜欢的插画，看完就随手翻过去了，没有保存。为什么呢？ 因为以我对自己的了解，图片下载下来，就相当于放进了垃圾桶。 并不是因为本地的文件管理有多乱，而是因为，几乎没有用鼠标打开文件管理器的习惯。</p>

<p>现在我获取信息的流量入口最常用的只有两个：1. 终端 2. 浏览器</p>

<p>于是乎，一个想法油然而生：</p>

<blockquote>
<p>把插画存到浏览器吧！</p>
</blockquote>

<p>于是就立刻构思，动手写了这款插件。</p>

<h3 id="toc_3">1.2 应该有什么功能?</h3>

<p>功能很简单，<br/>
<strong>保存操作</strong>：1. 对图片点击右键 2. 选择&quot;保存到浏览器..&quot; 之类的选项<br/>
<strong>查看操作</strong>：1. 点击插件图标 查看保存过的图片。<br/>
<strong>其它</strong>：1. 图片同步到云端，也可保存到浏览器本地。2. 既然要保存到云端，自然需要账号系统</p>

<h2 id="toc_4">2. 开发需要解决的核心问题</h2>

<blockquote>
<p>核心问题有两个，一个是数据云存储问题，一个是图片防盗链问题。</p>
</blockquote>

<p><strong>云存储问题，帐号系统，多端同步</strong><br/>
最开始只想做浏览器本地的存储，使用<code>Chrome</code>提供的<code>localStorage</code>存在本地就。<br/>
后来因为<code>localStorage</code>并不支持数据库语法查询，有很多不便。使用过程中又发现多端同步在体验上的优越性，决定要把存储放到云上。</p>

<p><strong>图片防盗链问题</strong><br/>
看了些资料，解决方式基本可以分为两种。</p>

<p>一类使用前端js嵌入<code>iframe</code>解决，优点是解决方式简单，问题是<code>Chrome</code>插件不支持页面嵌入式的<code>js</code>脚本。所以这个方案pass。</p>

<p>第二类使用后台服务器做反防盗链措施，作为中转给前端使用。优点是不受<code>chrome</code>插件的各种安全机制的限制，缺点是需要后台支持，增加工作量和资源成本。<br/>
使用第二类完成。</p>

<h2 id="toc_5">3. 具体解决方案</h2>

<blockquote>
<p>云存储及帐号系统使用<code>LeanCloud</code>提供的<code>存储服务</code>解决。<br/>
反防盗链接口使用<code>LeanCloud</code>提供的<code>云引擎</code>搭建<code>NodeJs</code>后台。</p>
</blockquote>

<p>啰嗦一句，为什么要使用<code>LeanCloud</code>? <br/>
一是对我的需求可以做到完全免费，二是它们的文档实在是太xx的好用了。</p>

<h3 id="toc_6">3.1 帐号系统</h3>

<p>参照：<a href="https://leancloud.cn/docs/leanstorage-started-js.html">数据存储入门教程 · JavaScript</a></p>

<p>实现过程基本照抄这个教程的代码。后台账号系统包括对账号的重复检测、密码加密、session等都已经实现。</p>

<blockquote>
<p>我们要做的，就是调用前端的这几个<strong>关键方法</strong>，实现简单的注册、登陆、退出:</p>
</blockquote>

<pre><code>  // LeanCloud - 注册
  // https://leancloud.cn/docs/leanstorage_guide-js.html#注册
  var user = new AV.User();
  user.setUsername(username);
  user.setPassword(password);
  user.setEmail(email);
  user.signUp().then(function (loginedUser) {
    // 注册成功
  }, (function (error) {
      alert(JSON.stringify(error));
  }));


  // LeanCloud - 登录
  // https://leancloud.cn/docs/leanstorage_guide-js.html#用户名和密码登录
  AV.User.logIn(username, password).then(function (loginedUser) {
    // 登录成功
  }, function (error) {
    alert(JSON.stringify(error));
  });


  // LeanCloud - 当前用户信息
  // https://leancloud.cn/docs/leanstorage_guide-js.html#当前用户
  var currentUser = AV.User.current();


  // 退出登陆
  AV.User.logOut();

</code></pre>

<h3 id="toc_7">3.2 存储服务</h3>

<blockquote>
<p>使用账号系统为每个用户添加身份信息后，存储部分就只需要把<code>数据</code> + <code>用户身份信息</code>一同上传或下载就可以了。</p>
</blockquote>

<p>照样只贴关键方法</p>

<pre><code>// 初始化类(在数据库中表现为数据表`ImageRepo`)和实例(数据库中表现为一条数据)
this.ImageRepo = AV.Object.extend(&#39;ImageRepo&#39;);
var repo = new this.ImageRepo();
// 填充数据
repo.put(&#39;username&#39;, &#39;xxx&#39;);
// 上传数据
repo.save().then(function (repo) {
    }, function (error) {
    });

// 下载数据
// 初始化对&#39;ImageRepo&#39;表的查询
var query = new AV.Query(&#39;ImageRepo&#39;);
// 查询条件为 username字段等于&#39;xxx&#39;
query.equalTo(&#39;username&#39;, &#39;xxx&#39;);
// 查询
query.find().then(function(results) {
    // 遍历results
    // 在页面添加解决防盗链问题后的图片
}, function(error) {
});
</code></pre>

<h3 id="toc_8">3.3 使用<code>LeanEngine</code>做反防盗链中转接口</h3>

<p><strong>要实现的效果是:</strong><br/>
1. 我有一个防盗链图片连接<code>abc.com/xxx.png</code>。<br/>
2. 我的接口url是<code>http://codeli.leanapp.cn/image?url=xxx</code>。<br/>
3. 访问<code>http://codeli.leanapp.cn/image?url=abc.com/xxx.png</code>可访问原图，不受防盗链措施限制。</p>

<blockquote>
<p>主要原理很简单，后台处理图片请求时更改<code>header</code>中的<code>referer</code>字段，将结果作为<code>response</code>返回。</p>
</blockquote>

<p>关于这部分的实现，欢迎阅读我的另一篇文章，就不再赘述：<br/>
<a href="http://www.jianshu.com/p/7b9f7cd6dce5">服务器作防盗链图片中转，nodejs 上手项目简明教程</a></p>

<blockquote>
<p>关于<code>LeanEngin</code>的使用，文档如下，使用方法非常简单。<br/>
<a href="https://leancloud.cn/docs/leanengine_quickstart.html">云引擎快速入门</a></p>

<p>云引擎支持<code>NodeJS</code> <code>Python</code> <code>PHP</code> <code>JAVA</code> <br/>
只需要下载云引擎命令行工具<code>lean</code>，然后输入几行命令就可以建立一个你熟悉的web框架。<br/>
然后，使用你熟悉的语言编写反防盗链实现就行了。</p>
</blockquote>

<h3 id="toc_9">3.4 Chrome 插件实现</h3>

<blockquote>
<p>有了 3.1~3.3 的实现，这部分就是简单的插件部署和业务逻辑了。</p>
</blockquote>

<p>Chrome 插件结构如图：<br/>
<img src="http://7xrnu9.com1.z0.glb.clouddn.com/chrome%E6%8F%92%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="图片来自 蒋国纲的技术博客"/></p>

<p><strong>主要业务：</strong><br/>
1. 在<code>popup</code>窗口中添加<code>注册</code> <code>登陆</code> <code>退出</code> 等业务。<br/>
2. 打开<code>popup</code> 窗口时从云端获取指定账号下保存的图片信息，并展示。若未登陆，则从浏览器<code>localStorage</code>获取并展示。<br/>
3. <code>background script</code> 中添加右键菜单项: 当目标是图片时，显示<code>Keep image in browser</code>。<br/>
4. 点击<code>Keep image in browser</code>, 执行保存业务逻辑: 若登陆了，保存到云端。若未登录，保存到浏览器<code>localStorage</code>。</p>

<blockquote>
<p>具体实现见我的github项目:  <a href="https://github.com/auv1107/KeepImageInBrowser">KeepImageInBrowser</a><br/>
插件Web Store地址： <a href="https://chrome.google.com/webstore/detail/favorite-image/dboialkignkpkbggkomglilgdhkgijfp">Favorite Image</a></p>
</blockquote>

<h2 id="toc_10">4. 最后，对去后端化的看法</h2>

<p>前段时间在知乎上看到了一个问题,我也顺便说下自己的看法。</p>

<blockquote>
<p>web后端会不会变得越来越不需要?</p>
</blockquote>

<p>像bmob和leancloud这类后台云服务的流行有一段日子了，使用这些服务使一些web、app的开发周期大大缩减。这对于小团队和初创公司尤为方便。</p>

<p>但这并不意味着不再需要自己开发后台。不是因为他们提供的服务不够全面(相反，我倒认为这类服务将向着全面、便捷、快速发展)，而是因为很多公司和产品，为了保持服务的质量和稳定，突出自己产品的特性，需要自己定制自己的后台，有针对性的去优化某些模块。<br/>
云服务作为大众服务平台难以为每个产品做定制。</p>

<p>类似于游戏引擎，如今各个平台都不缺乏优秀的游戏引擎。可是仍有公司和团队耗费大量的成本自研游戏引擎，就是希望能配合自己的游戏系统，完美地展现自己的游戏。</p>

<p>一样的，后台云服务和自定制的后台，是相交但永远不会重合的关系。 他们彼此之间相互影响，共同进步。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[生而为人，总要经历送礼这回事。逢年过节倒还好，亲戚朋友送些吃的喝的也就过去了。可是平时见朋友，过生日之类，选择什么礼物就成了一大烦恼。]]></title>
    <link href="lixindong.top/14805196774412.html"/>
    <updated>2016-11-30T23:27:57+08:00</updated>
    <id>lixindong.top/14805196774412.html</id>
    <content type="html"><![CDATA[
<p>有人说，送礼重要的是情谊，无论礼物轻重贵贱，只要真心祝福，朋友自然会开心。<br/>
道理是这样，我也在一定程度上表示认同。所以我今天要讲的不是价格高低，也不是品类含义，而只是讲讲我在选择礼物时的思考。</p>

<h2 id="toc_0">消耗品 or 非消耗品</h2>

<p>在北京租房经历过几次搬家，加之对山下英子老师断舍离思想的认同，让我形成了「如果不是必要的，就不要随意添加」的观念。以至于每每要准备礼物，我都要消瘦三斤。<br/>
因为万一选取不当，便会成为被赠与者的负担。<br/>
“丢弃过意不去，放在家里不合适，礼物本身不适合转送，干脆建个专门收藏礼物的收藏馆吧”。于是新的创业项目风火出炉。<br/>
因此若非对对方很了解或事先询问，我定会选择消耗品或生命周期较短的物品。女生花、零食、化妆品成为首选，男生吃顿饭就算过去了。</p>

<h2 id="toc_1">书</h2>

<p>书是我比较倾向的一类。<br/>
一来身边朋友大多抱着大学文凭，书的品类众多，因此即便对方早已对读书嗤之以鼻，也总能有那么几本适合的。<br/>
二来书籍适合转送。即便很不巧地送错了书，被赠予者也可以无压力地转送出去。如上所说，送礼重要的是心意，心意传达到了，自然皆大欢喜。<br/>
缺点是，除非对方嗜书如命，否则很难从这礼物中感受到惊喜。</p>

<h2 id="toc_2">红包</h2>

<p>关系很铁或很官方时没问题。</p>

<h2 id="toc_3">兴趣对口周边</h2>

<p>简单粗暴但仍需仔细确认。<br/>
如果对方是宅宅，送手办。<br/>
程序员，耳机键盘科技产品。<br/>
运动达人，运动装备。<br/>
程序猿，吃。<br/>
设计师，钱。</p>

<h2 id="toc_4">是否要事先询问</h2>

<p>当我做好打算赠送非消耗品时，一定会认真询问。虽然有时会略显尴尬，又让对方失去了惊喜。但是对于一个信奉简约思想的朋友来说，无疑是极为合适的。重要的是，虽然没了惊喜，却能让人感受到你满满的诚意。</p>

<p>说了这些，回头想想现实其实并没这么复杂。现实中多的是收到什么礼物都感到惊喜的朋友。只是当对方是一个对生活认真且谨慎的人，而他又对你很重要时，切记，要谨慎处理。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android中 Integer对象使用==运算符还是equals()方法比较大小?]]></title>
    <link href="lixindong.top/14730898296691.html"/>
    <updated>2016-09-05T23:37:09+08:00</updated>
    <id>lixindong.top/14730898296691.html</id>
    <content type="html"><![CDATA[
<p>最近项目组使用findbugs辅助检测代码问题，其中一个问题提到了Integer对象的值比较问题。虽然心里很清楚，java语言类对象的双等号操作符默认比较的是对象的地址，即是否是同一个对象。可是对于Integer、Long这类基本类型的扩展类，心想存在特殊处理的可能，所以还是查了下资料，主要是解释一些心里的疑惑。</p>

<h2 id="toc_0">疑问?</h2>

<ol>
<li>java 能不能重载+、-、 =、==这些运算符</li>
<li>java的Integer、Long这些类型的==运算符是比较地址还是使用<code>equals</code>的结果</li>
<li>为什么两个值为10的Integer对象，用==比较的结果是true，而两个值为1000的Integer对象的比较结果为false?</li>
</ol>

<h2 id="toc_1">解答！</h2>

<h3 id="toc_2">1. 能不能重载运算符？</h3>

<p>不能。<br/>
有些人疑问，可是String对象可以有形如<code>&quot;hello worl&quot; + &#39;d&#39;</code>的操作，基本运算应该是不支持的。<br/>
这里是因为编译器在编译时处理成了<code>Object s2 = (new StringBuilder(&quot;hello world&quot;)).append(&#39;d&#39;).toString();</code>的形式。</p>

<h3 id="toc_3">2. java的Integer、Long这些类型的==运算符是比较地址还是使用<code>equals</code>的结果?</h3>

<p>比较地址。<br/>
因为不能重载运算符，所以即便是这些特殊的类，依然只能在编译器上动动手脚。</p>

<h3 id="toc_4">3. 为什么两个值为10的Integer对象，用==比较的结果是true，而两个值为1000的Integer对象的比较结果为false?</h3>

<p>Integer为-128~127范围内的对象做了缓存处理。<br/>
<code><br/>
public static Integer valueOf(int i) {<br/>
    if(i &gt;= -128 &amp;&amp; i &lt;= IntegerCache.high)<br/>
        return IntegerCache.cache[i + 128];<br/>
    else<br/>
        return new Integer(i);<br/>
}<br/>
</code><br/>
无论你是使用new Integer(..)还是Integer.valueOf(..)获取对象，<br/>
只要值在-128到127的范围内，拿到的就是缓存好的对象。因此无论是<code>==运算符</code>还是equals()方法，只要值相同，结果都是true。<br/>
而如果你的值在这个范围之外，<code>==</code>必然返回false，equals()方法的返回值依对象的值而定。</p>

<h2 id="toc_5">结论</h2>

<p>无论如何，请使用equals()方法比较大小。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何在Java中避免equals方法的隐藏陷阱]]></title>
    <link href="lixindong.top/14730873130757.html"/>
    <updated>2016-09-05T22:55:13+08:00</updated>
    <id>lixindong.top/14730873130757.html</id>
    <content type="html"><![CDATA[
<p>今天看资料时看到coolshell的这篇文章，获益匪浅，收藏到文库里。</p>

<p>译文原文：<a href="http://coolshell.cn/articles/1051.html">http://coolshell.cn/articles/1051.html</a><br/>
英文原文：<a href="http://www.artima.com/lejava/articles/equality.html">http://www.artima.com/lejava/articles/equality.html</a></p>

<p><strong>译者注</strong> :你可能会觉得Java很简单，Object的equals实现也会非常简单，但是事实并不是你想象的这样，耐心的读完本文，你会发现你对Java了解的是如此的少。如果这篇文章是一份Java程序员的入职笔试，那么不知道有多少人会掉落到这样的陷阱中。原文转自<a href="http://www.artima.com/lejava/articles/equality.html">http://www.artima.com/lejava/articles/equality.html</a> 三位作者都是不同领域的大拿，有兴趣的读者可以从上面这个连接直接去阅读原文。</p>

<p><strong>摘要</strong></p>

<p>本文描述重载equals方法的技术，这种技术即使是具现类的子类增加了字段也能保证equal语义的正确性。</p>

<p>在《Effective Java》的第8项中，Josh Bloch描述了当继承类作为面向对象语言中的等价关系的基础问题，要保证派生类的equal正确性语义所会面对的困难。Bloch这样写到：</p>

<blockquote>
<p><strong>除非你忘记了面向对象抽象的好处，否则在当你继承一个新类或在类中增加了一个值组件时你无法同时保证equal的语义依然正确</strong></p>
</blockquote>

<p>在《Programming in Scala》中的第28章演示了一种方法，这种方法允许即使继承了新类，增加了新的值组件，equal的语义仍然能得到保证。虽然在这本书中这项技术是在使用Scala类环境中，但是这项技术同样可以应用于Java定义的类中。在本文中的描述来自于Programming in Scala中的文字描述，但是代码被我从scala翻译成了Java</p>

<h4 id="toc_0">常见的等价方法陷阱</h4>

<p>java.lang.Object 类定义了equals这个方法，它的子类可以通过重载来覆盖它。不幸的是，在面向对象中写出正确的equals方法是非常困难的。事实上，在研究了大量的Java代码后，2007 paper的作者得出了如下的一个结论：</p>

<blockquote>
<p>几乎所有的equals方法的实现都是错误的！</p>
</blockquote>

<p>这个问题是因为等价是和很多其他的事物相关联。例如其中之一，一个的类型C的错误等价方法可能意味着你无法将这个类型C的对象可信赖的放入到容器中。比如说，你有两个元素elem1和elem2他们都是类型C的对象，并且他们是相等，即<code>elem1.equals(elm2)</code>返回ture。但是，只要这个equals方法是错误的实现，那么你就有可能会看见如下的一些行为：</p>

<pre><code>Set hashSet&lt;C&gt; = new java.util.HashSet&lt;C&gt;();
hashSet.add(elem1);
hashSet.contains(elem2);    // returns false!&lt;/pre&gt;
</code></pre>

<p>当equals重载时，这里有4个会引发equals行为不一致的常见陷阱：</p>

<ol>
<li> 定义了错误的equals方法签名(signature) Defining equals with the wrong signature.</li>
<li> 重载了equals的但没有同时重载hashCode的方法。 Changing equals without also changing hashCode.</li>
<li> 建立在会变化字域上的equals定义。 Defining equals in terms of mutable fields.</li>
<li> 不满足等价关系的equals错误定义 Failing to define equals as an equivalence relation.</li>
</ol>

<p>在剩下的章节中我们将依次讨论这4中陷阱。</p>

<h4 id="toc_1">陷阱1：定义错误equals方法签名(signature)</h4>

<p>考虑为下面这个简单类Point增加一个等价性方法：</p>

<pre><code>public class Point {

    private final int x;
    private final int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    // ...
}
</code></pre>

<p>看上去非常明显，但是按照这种方式来定义equals就是错误的。</p>

<pre><code>// An utterly wrong definition of equals
public boolean equals(Point other) {
  return (this.getX() == other.getX() &amp;&amp; this.getY() == other.getY());
}
</code></pre>

<p>这个方法有什么问题呢？初看起来，它工作的非常完美：</p>

<pre><code>Point p1 = new Point(1, 2);
Point p2 = new Point(1, 2);

Point q = new Point(2, 3);

System.out.println(p1.equals(p2)); // prints true

System.out.println(p1.equals(q)); // prints false
</code></pre>

<p>然而，当我们一旦把这个Point类的实例放入到一个容器中问题就出现了：</p>

<pre><code>import java.util.HashSet;

HashSet&lt;Point&gt; coll = new HashSet&lt;Point&gt;();
coll.add(p1);

System.out.println(coll.contains(p2)); // prints false
</code></pre>

<p>为什么coll中没有包含p2呢？甚至是p1也被加到集合里面，p1和p2是是等价的对象吗？在下面的程序中，我们可以找到其中的一些原因，定义p2a是一个指向p2的对象，但是p2a的类型是Object而非Point类型：</p>

<pre><code>Object p2a = p2;
</code></pre>

<p>现在我们重复第一个比较，但是不再使用p2而是p2a,我们将会得到如下的结果：</p>

<pre><code>System.out.println(p1.equals(p2a)); // prints false
</code></pre>

<p>到底是那里出了了问题？事实上，之前所给出的equals版本并没有覆盖Object类的equals方法，因为他的类型不同。下面是Object的equals方法的定义</p>

<pre><code>public boolean equals(Object other)
</code></pre>

<p>因为Point类中的equals方法使用的是以Point类而非Object类做为参数，因此它并没有覆盖Object中的equals方法。而是一种变化了的重载。在Java中重载被解析为静态的参数类型而非运行期的类型，因此当静态参数类型是Point,Point的equals方法就被调用。然而当静态参数类型是Object时，Object类的equals就被调用。因为这个方法并没有被覆盖，因此它仍然是实现成比较对象标示。这就是为什么虽然p1和p2a具有同样的x,y值，”p1.equals(p2a)”仍然返回了false。这也是会什么HasSet的contains方法返回false的原因，因为这个方法操作的是泛型，他调用的是一般化的Object上equals方法而非Point类上变化了的重载方法equals</p>

<p>一个更好但不完美的equals方法定义如下：</p>

<pre><code>// A better definition, but still not perfect
@Override public boolean equals(Object other) {
    boolean result = false;
    if (other instanceof Point) {
        Point that = (Point) other;
        result = (this.getX() == that.getX() &amp;&amp; this.getY() == that.getY());
    }
    return result;
}
</code></pre>

<p>现在equals有了正确的类型，它使用了一个Object类型的参数和一个返回布尔型的结果。这个方法的实现使用instanceof操作和做了一个造型。它首先检查这个对象是否是一个Point类，如果是，他就比较两个点的坐标并返回结果，否则返回false。</p>

<h4 id="toc_2">陷阱2：重载了equals的但没有同时重载hashCode的方法</h4>

<p>如果你使用上一个定义的Point类进行p1和p2a的反复比较，你都会得到你预期的true的结果。但是如果你将这个类对象放入到HashSet.contains()方法中测试，你就有可能仍然得到false的结果：</p>

<pre><code>Point p1 = new Point(1, 2);
Point p2 = new Point(1, 2);

HashSet&lt;Point&gt; coll = new HashSet&lt;Point&gt;();
coll.add(p1);

System.out.println(coll.contains(p2)); // 打印 false (有可能)
</code></pre>

<p>事实上，这个个结果不是100%的false，你也可能有返回ture的经历。如果你得到的结果是true的话，那么你试试其他的坐标值，最终你一定会得到一个在集合中不包含的结果。导致这个结果的原因是Point重载了equals却没有重载hashCode。</p>

<p>注意上面例子的的容器是一个HashSet，这就意味着容器中的元素根据他们的哈希码被被放入到”哈希桶 hash buckets”中。contains方法首先根据哈希码在哈希桶中查找，然后让桶中的所有元素和所给的参数进行比较。现在，虽然最后一个Point类的版本重定义了equals方法，但是它并没有同时重定义hashCode。因此，hashCode仍然是Object类的那个版本，即：所分配对象的一个地址的变换。所以p1和p2的哈希码理所当然的不同了，甚至是即时这两个点的坐标完全相同。不同的哈希码导致他们具有极高的可能性被放入到集合中不同的哈希桶中。contains方法将会去找p2的哈希码对应哈希桶中的匹配元素。但是大多数情况下，p1一定是在另外一个桶中，因此，p2永远找不到p1进行匹配。当然p2和p2也可能偶尔会被放入到一个桶中，在这种情况下，contains的结果就为true了。</p>

<p>最新一个Point类实现的问题是，它的实现违背了作为Object类的定义的hashCode的语义。</p>

<blockquote>
<p>如果两个对象根据equals(Object)方法是相等的，那么在这两个对象上调用hashCode方法应该产生同样的值</p>
</blockquote>

<p>事实上，在Java中，hashCode和equals需要一起被重定义是众所周知的。此外，hashCode只可以依赖于equals依赖的域来产生值。对于Point这个类来说，下面的的hashCode定义是一个非常合适的定义。</p>

<pre><code>public class Point {

    private final int x;
    private final int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    @Override public boolean equals(Object other) {
        boolean result = false;
        if (other instanceof Point) {
            Point that = (Point) other;
            result = (this.getX() == that.getX() &amp;&amp; this.getY() == that.getY());
        }
        return result;
    }

    @Override public int hashCode() {
        return (41 * (41 + getX()) + getY());
    }

}
</code></pre>

<p>这只是hashCode一个可能的实现。x域加上常量41后的结果再乘与41并将结果在加上y域的值。这样做就可以以低成本的运行时间和低成本代码大小得到一个哈希码的合理的分布(<strong>译者注：</strong>性价比相对较高的做法)。</p>

<p>增加hashCode方法重载修正了定义类似Point类等价性的问题。然而，关于类的等价性仍然有其他的问题点待发现。</p>

<h4 id="toc_3">陷阱3：建立在会变化字段上的equals定义</h4>

<p>让我们在Point类做一个非常微小的变化</p>

<pre><code>public class Point {

    private int x;
    private int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    public void setX(int x) { // Problematic
        this.x = x;
    }

    public void setY(int y) {
        this.y = y;
    }

    @Override public boolean equals(Object other) {
        boolean result = false;
        if (other instanceof Point) {
            Point that = (Point) other;
            result = (this.getX() == that.getX() &amp;&amp; this.getY() == that.getY());
        }
        return result;
    }

    @Override public int hashCode() {
        return (41 * (41 + getX()) + getY());
    }
}
</code></pre>

<p>唯一的不同是x和y域不再是final，并且两个set方法被增加到类中来，并允许客户改变x和y的值。equals和hashCode这个方法的定义现在是基于在这两个会发生变化的域上，因此当他们的域的值改变时，结果也就跟着改变。因此一旦你将这个point对象放入到集合中你将会看到非常神奇的效果。</p>

<pre><code>Point p = new Point(1, 2);

HashSet&lt;Point&gt; coll = new HashSet&lt;Point&gt;();
coll.add(p);

System.out.println(coll.contains(p)); // 打印 true
</code></pre>

<p>现在如果你改变p中的一个域，这个集合中还会包含point吗，我们将拭目以待。</p>

<pre><code>p.setX(p.getX() + 1);

System.out.println(coll.contains(p)); // (有可能)打印 false
</code></pre>

<p>看起来非常的奇怪。p去那里去了？如果你通过集合的迭代器来检查p是否包含，你将会得到更奇怪的结果。</p>

<pre><code>Iterator&lt;Point&gt; it = coll.iterator();
boolean containedP = false;
while (it.hasNext()) {
    Point nextP = it.next();
    if (nextP.equals(p)) {
        containedP = true;
        break;
    }
}

System.out.println(containedP); // 打印 true
</code></pre>

<p>结果是，集合中不包含p，但是p在集合的元素中！到底发生了什么！当然，所有的这一切都是在x域的修改后才发生的，p最终的的hashCode是在集合coll错误的哈希桶中。即，原始哈希桶不再有其新值对应的哈希码。换句话说，p已经在集合coll的是视野范围之外，虽然他仍然属于coll的元素。</p>

<p>从这个例子所得到的教训是，当equals和hashCode依赖于会变化的状态时，那么就会给用户带来问题。如果这样的对象被放入到集合中，用户必须小心，不要修改这些这些对象所依赖的状态，这是一个小陷阱。如果你需要根据对象当前的状态进行比较的话，你应该不要再重定义equals，应该起其他的方法名字而不是equals。对于我们的Point类的最后的定义，我们最好省略掉hashCode的重载，并将比较的方法名命名为equalsContents，或其他不同于equals的名字。那么Point将会继承原来默认的equals和hashCode的实现，因此当我们修改了x域后p依然会呆在其原来在容器中应该在位置。</p>

<h4 id="toc_4">陷阱4：不满足等价关系的equals错误定义</h4>

<p>Object中的equals的规范阐述了equals方法必须实现在非null对象上的等价关系：</p>

<ul>
<li>  自反原则：对于任何非null值X,表达式x.equals(x)总返回true。</li>
<li>  等价性：对于任何非空值x和y，那么当且仅当y.equals(x)返回真时，x.equals(y)返回真。</li>
<li>  传递性：对于任何非空值x,y,和z，如果x.equals(y)返回真，且y.equals(z)也返回真，那么x.equals(z)也应该返回真。</li>
<li>  一致性：对于非空x,y，多次调用x.equals(y)应该一致的返回真或假。提供给equals方法比较使用的信息不应该包含改过的信息。</li>
<li>  对于任何非空值x,x.equals(null)应该总返回false.</li>
</ul>

<p>Point类的equals定义已经被开发成了足够满足equals规范的定义。然而，当考虑到继承的时候，事情就开始变得非常复杂起来。比如说有一个Point的子类ColoredPoint，它比Point多增加了一个类型是Color的color域。假设Color被定义为一个枚举类型：</p>

<pre><code>public enum Color {
    RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET;
}
</code></pre>

<p>ColoredPoint重载了equals方法，并考虑到新加入color域，代码如下：</p>

<pre><code>public class ColoredPoint extends Point { // Problem: equals not symmetric

    private final Color color;

    public ColoredPoint(int x, int y, Color color) {
        super(x, y);
        this.color = color;
    }

    @Override public boolean equals(Object other) {
        boolean result = false;
        if (other instanceof ColoredPoint) {
            ColoredPoint that = (ColoredPoint) other;
            result = (this.color.equals(that.color) &amp;&amp; super.equals(that));
        }
        return result;
    }
}
</code></pre>

<p>这是很多程序员都有可能写成的代码。注意在本例中，类ColoredPointed不需要重载hashCode，因为新的ColoredPoint类上的equals定义，严格的重载了Point上equals的定义。hashCode的规范仍然是有效，如果两个着色点(colored point)相等，其坐标必定相等，因此它的hashCode也保证了具有同样的值。</p>

<p>对于ColoredPoint类自身对象的比较是没有问题的，但是如果使用ColoredPoint和Point混合进行比较就要出现问题。</p>

<pre><code>Point p = new Point(1, 2);

ColoredPoint cp = new ColoredPoint(1, 2, Color.RED);

System.out.println(p.equals(cp)); // 打印真 true

System.out.println(cp.equals(p)); // 打印假 false
</code></pre>

<p>“p等价于cp”的比较这个调用的是定义在Point类上的equals方法。这个方法只考虑两个点的坐标。因此比较返回真。在另外一方面，“cp等价于p”的比较这个调用的是定义在ColoredPoint类上的equals方法，返回的结果却是false，这是因为p不是ColoredPoint，所以equals这个定义违背了对称性。</p>

<p>违背对称性对于集合来说将导致不可以预期的后果，例如：</p>

<pre><code>Set&lt;Point&gt; hashSet1 = new java.util.HashSet&lt;Point&gt;();
hashSet1.add(p);
System.out.println(hashSet1.contains(cp));    // 打印 false

Set&lt;Point&gt; hashSet2 = new java.util.HashSet&lt;Point&gt;();
hashSet2.add(cp);
System.out.println(hashSet2.contains(p));    // 打印 true
</code></pre>

<p>因此虽然p和cp是等价的，但是contains测试中一个返回成功，另外一个却返回失败。</p>

<p>你如何修改equals的定义，才能使得这个方法满足对称性？本质上说有两种方法，你可以使得这种关系变得更一般化或更严格。更一般化的意思是这一对对象，a和b，被用于进行对比，无论是a比b还是b比a 都返回true，下面是代码：</p>

<pre><code>public class ColoredPoint extends Point { // Problem: equals not transitive

    private final Color color;

    public ColoredPoint(int x, int y, Color color) {
        super(x, y);
        this.color = color;
    }

    @Override public boolean equals(Object other) {
        boolean result = false;
        if (other instanceof ColoredPoint) {
            ColoredPoint that = (ColoredPoint) other;
            result = (this.color.equals(that.color) &amp;&amp; super.equals(that));
        }
        else if (other instanceof Point) {
            Point that = (Point) other;
            result = that.equals(this);
        }
        return result;
    }
}
</code></pre>

<p>在ColoredPoint中的equals的新定义比老定义中检查了更多的情况:如果对象是一个Point对象而不是ColoredPoint，方法就转变为Point类的equals方法调用。这个所希望达到的效果就是equals的对称性，不管”cp.equals(p)”还是”p.equals(cp)”的结果都是true。然而这种方法，equals的规范还是被破坏了，现在的问题是这个新等价性不满足传递性。考虑下面的一段代码实例，定义了一个点和这个点上上两种不同颜色点：</p>

<pre><code>ColoredPoint redP = new ColoredPoint(1, 2, Color.RED);
ColoredPoint blueP = new ColoredPoint(1, 2, Color.BLUE);
</code></pre>

<p>redP等价于p，p等价于blueP</p>

<pre><code>System.out.println(redP.equals(p)); // prints true

System.out.println(p.equals(blueP)); // prints true
</code></pre>

<p>然而，对比redP和blueP的结果是false:</p>

<pre><code>System.out.println(redP.equals(blueP)); // 打印 false
</code></pre>

<p>因此，equals的传递性就被违背了。</p>

<p>使equals的关系更一般化似乎会将我们带入到死胡同。我们应该采用更严格化的方法。一种更严格化的equals方法是认为不同类的对象是不同的。这个可以通过修改Point类和ColoredPoint类的equals方法来达到。你能增加额外的比较来检查是否运行态的这个Point类和那个Point类是同一个类，就像如下所示的代码一样：</p>

<pre><code>// A technically valid, but unsatisfying, equals method
public class Point {

    private final int x;
    private final int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    @Override public boolean equals(Object other) {
        boolean result = false;
        if (other instanceof Point) {
            Point that = (Point) other;
            result = (this.getX() == that.getX() &amp;&amp; this.getY() == that.getY()
                    &amp;&amp; this.getClass().equals(that.getClass()));
        }
        return result;
    }

    @Override public int hashCode() {
        return (41 * (41 + getX()) + getY());
    }
}
</code></pre>

<p>你现在可以将ColoredPoint类的equals实现用回刚才那个不满足对称性要的equals实现了。</p>

<pre><code>public class ColoredPoint extends Point { // 不再违反对称性需求

    private final Color color;

    public ColoredPoint(int x, int y, Color color) {
        super(x, y);
        this.color = color;
    }

    @Override public boolean equals(Object other) {
        boolean result = false;
        if (other instanceof ColoredPoint) {
            ColoredPoint that = (ColoredPoint) other;
            result = (this.color.equals(that.color) &amp;&amp; super.equals(that));
        }
        return result;
    }
}
</code></pre>

<p>这里，Point类的实例只有当和另外一个对象是同样类，并且有同样的坐标时候，他们才被认为是相等的，即意味着 .getClass()返回的是同样的值。这个新定义的等价关系满足了对称性和传递性因为对于比较对象是不同的类时结果总是false。所以着色点(colored point)永远不会等于点(point)。通常这看起来非常合理，但是这里也存在着另外一种争论——这样的比较过于严格了。</p>

<p>考虑我们如下这种稍微的迂回的方式来定义我们的坐标点(1,2)</p>

<pre><code>Point pAnon = new Point(1, 1) {
    @Override public int getY() {
        return 2;
    }
};
</code></pre>

<p>pAnon等于p吗？答案是假，因为p和pAnon的java.lang.Class对象不同。p是Point，而pAnon是Point的一个匿名派生类。但是，非常清晰的是pAnon的确是在坐标1，2上的另外一个点。所以将他们认为是不同的点是没有理由的。</p>

<h4 id="toc_5">canEqual 方法</h4>

<p>到此，我们看其来似乎是遇到阻碍了，存在着一种正常的方式不仅可以在不同类继承层次上定义等价性，并且保证其等价的规范性吗？事实上，的确存在这样的一种方法，但是这就要求除了重定义equals和hashCode外还要另外的定义一个方法。基本思路就是在重载equals(和hashCode)的同时，它应该也要要明确的声明这个类的对象永远不等价于其他的实现了不同等价方法的超类的对象。为了达到这个目标，我们对每一个重载了equals的类新增一个方法canEqual方法。这个方法的方法签名是：</p>

<pre><code>public boolean canEqual(Object other)
</code></pre>

<p>如果other 对象是canEquals(重)定义那个类的实例时，那么这个方法应该返回真，否则返回false。这个方法由equals方法调用，并保证了两个对象是可以相互比较的。下面Point类的新的也是最终的实现：</p>

<pre><code>public class Point {

    private final int x;
    private final int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    @Override public boolean equals(Object other) {
        boolean result = false;
        if (other instanceof Point) {
            Point that = (Point) other;
            result =(that.canEqual(this) &amp;&amp; this.getX() == that.getX() &amp;&amp; this.getY() == that.getY());
        }
        return result;
    }

    @Override public int hashCode() {
        return (41 * (41 + getX()) + getY());
    }
    public boolean canEqual(Object other) {
        return (other instanceof Point);
    }

}
</code></pre>

<p>这个版本的Point类的equals方法中包含了一个额外的需求，通过canEquals方法来决定另外一个对象是否是是满足可以比较的对象。在Point中的canEqual宣称了所有的Point类实例都能被比较。</p>

<p>下面是ColoredPoint相应的实现</p>

<pre><code>public class ColoredPoint extends Point { // 不再违背对称性

    private final Color color;

    public ColoredPoint(int x, int y, Color color) {
        super(x, y);
        this.color = color;
    }

    @Override public boolean equals(Object other) {
        boolean result = false;
        if (other instanceof ColoredPoint) {
            ColoredPoint that = (ColoredPoint) other;
            result = (that.canEqual(this) &amp;&amp; this.color.equals(that.color) &amp;&amp; super.equals(that));
        }
        return result;
    }

    @Override public int hashCode() {
        return (41 * super.hashCode() + color.hashCode());
    }

    @Override public boolean canEqual(Object other) {
        return (other instanceof ColoredPoint);
    }
}
</code></pre>

<p>在上显示的新版本的Point类和ColoredPoint类定义保证了等价的规范。等价是对称和可传递的。比较一个Point和ColoredPoint类总是返回false。因为点p和着色点cp,“p.equals(cp)返回的是假。并且，因为cp.canEqual(p)总返回false。相反的比较，cp.equals(p)同样也返回false，由于p不是一个ColoredPoint，所以在ColoredPoint的equals方法体内的第一个instanceof检查就失败了。</p>

<p>另外一个方面，不同的Point子类的实例却是可以比较的，同样没有重定义等价性方法的类也是可以比较的。对于这个新类的定义，p和pAnon的比较将总返回true。下面是一些例子：</p>

<pre><code>Point p = new Point(1, 2);

ColoredPoint cp = new ColoredPoint(1, 2, Color.INDIGO);

Point pAnon = new Point(1, 1) {
    @Override public int getY() {
        return 2;
    }
};

Set&lt;Point&gt; coll = new java.util.HashSet&lt;Point&gt;();
coll.add(p);

System.out.println(coll.contains(p)); // 打印 true

System.out.println(coll.contains(cp)); // 打印 false

System.out.println(coll.contains(pAnon)); // 打印 true
</code></pre>

<p>这些例子显示了如果父类在equals的实现定义并调用了canEquals，那么开发人员实现的子类就能决定这个子类是否可以和它父类的实例进行比较。例如ColoredPoint，因为它以”一个着色点永远不可以等于普通不带颜色的点重载了” canEqual，所以他们就不能比较。但是因为pAnon引用的匿名子类没有重载canEqual,因此它的实例就可以和Point的实例进行对比。</p>

<p>canEqual方法的一个潜在的争论是它是否违背了Liskov替换准则(LSP)。例如，通过比较运行态的类来实现的比较技术(<strong>译者注：</strong> canEqual的前一版本，使用.getClass()的那个版本)，将导致不能定义出一个子类，这个子类的实例可以和其父类进行比较，因此就违背了LSP。这是因为，LSP原则是这样的，在任何你能使用父类的地方你都可以使用子类去替换它。在之前例子中，虽然cp的x,y坐标匹配那些在集合中的点，然而”coll.contains(cp)”仍然返回false，这看起来似乎违背得了LSP准则，因为你不能这里能使用Point的地方使用一个ColoredPointed。但是我们认为这种解释是错误的，因为LSP原则并没有要求子类和父类的行为一致，而仅要求其行为能一种方式满足父类的规范。</p>

<p>通过比较运行态的类来编写equals方法(<strong>译者注：</strong> canEqual的前一版本，使用.getClass()的那个版本)的问题并不是违背LSP准则的问题，但是它也没有为你指明一种创建派生类的实例能和父类实例进行对比的的方法。例如，我们使用这种运行态比较的技术在之前的”coll.contains(pAnon)”将会返回false，并且这并不是我们希望的。相反我们希望“coll.contains(cp)”返回false，因为通过在ColoredPoint中重载的equals，我基本上可以说，一个在坐标1，2上着色点和一个坐标1，2上的普通点并不是一回事。然而，在最后的例子中，我们能传递Point两种不同的子类实例到集合中contains方法，并且我们能得到两个不同的答案，并且这两个答案都正确。</p>

<p><strong>–全文完–</strong></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android GPS定位欺骗(模拟定位)的两种方式]]></title>
    <link href="lixindong.top/14720509840810.html"/>
    <updated>2016-08-24T23:03:04+08:00</updated>
    <id>lixindong.top/14720509840810.html</id>
    <content type="html"><![CDATA[
<p>前段时间发布的手游PokemonGo相信大家都有耳闻，而因为这个游戏在国内的坐标遭到了封锁，很多科学游戏方法也陆续涌现。好不热闹。<br/>
那其实，PokemonGo最初的版本，在大陆是可以通过简单的vpn+gps欺骗进行游戏的。<br/>
不过很快地，在新的版本更新中就封锁了这一方式。</p>

<p>而对Android系统使用GPS欺骗，应用场景也绝不只是这一个游戏而已。所以我今天来简单介绍一下可使用的几种方式。</p>

<blockquote>
<p>控制噪声的方式有三种：防止噪声产生，阻断噪声传播和防止噪声进入耳朵</p>
</blockquote>

<p>相对应的，</p>

<blockquote>
<p>修改GPS定位结果的三种途径： 编译时修改NLP结果，运行时修改LocationManager结果，从应用获取到的结果修改。</p>
</blockquote>

<h3 id="toc_0">1. 编译时修改NLP结果</h3>

<p>难度系数：五颗星<br/>
建议：想都别想<br/>
大概思路：修改nlp部分源码，重编系统</p>

<h3 id="toc_1">2. 运行时修改LocationManager结果</h3>

<p>这个分两类：</p>

<blockquote>
<p><strong>一类</strong>： 使用android自带的调试api，模拟gps provider的结果。</p>
</blockquote>

<pre><code>LocationManager.setTestProviderLocation(Provider, Location);
</code></pre>

<p>优点：简单，无需root<br/>
缺点：不稳定，特征明显，容易按特征嗅探到（有反作弊机制的游戏基本都能查出来），需要打开开发者的允许模拟位置选项</p>

<blockquote>
<p><strong>第二类</strong>: 使用xposed,传说中的android神器，用它对app_process进行注入。</p>
</blockquote>

<p>有什么用呢，就是你可以放个钩子，英文名叫hook。这个钩子能知道你系统里的每个应用什么时候调用了哪个函数，还能修改对应的这个函数。<br/>
说到这就懂了吧。比如你猜测对应app会使用LocationManager.getLastKnownLocation的结果。然后你用xposed把内存里的这个函数返回值改成 <code>纬度 N 39.832670° 东经 E116.460370°</code>，然后调用这个函数的程序看到的记过就是你修改之后的结果。<br/>
具体代码看这里吧（非本人repo，只是找了个简单易懂的demo）<br/>
<a href="https://github.com/YiuChoi/FakeGps/tree/master/app/src/main/java/name/caiyao/fakegps/hook">FakeGPS demo</a></p>

<p>优点：稳定，难以被反查<br/>
缺点：需要root</p>

<h3 id="toc_2">3. 对想欺骗的app反编译，修改结果</h3>

<p>该怎么做看标题就明白了。<br/>
步骤就是<br/>
1. 反编译<br/>
2. 找到所有使用了定位结果的位置<br/>
3. 修改结果<br/>
4. 重新打包</p>

<p>这个方式的优缺点也很明显。<br/>
优点： 无需root，稳定性强（前提是找准入口）<br/>
缺点： 技术水平要求高。根据应用复杂程度、混淆、安全策略等不同，难度差异较大。难易程度包括很多内容，包括混淆部分、入口寻找、签名验证等。 我也不熟啊，感兴趣的同学请自行深入学习吧。</p>

<p>————————</p>

<p>3类4种欺骗方式，各位看官收好。</p>

<p>以上。</p>

]]></content>
  </entry>
  
</feed>
