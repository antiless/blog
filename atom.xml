<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[博客未命名]]></title>
  <link href="lixindong.top/atom.xml" rel="self"/>
  <link href="lixindong.top/"/>
  <updated>2016-09-05T23:37:34+08:00</updated>
  <id>lixindong.top/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[Android中 Integer对象使用==运算符还是equals()方法比较大小?]]></title>
    <link href="lixindong.top/14730898296691.html"/>
    <updated>2016-09-05T23:37:09+08:00</updated>
    <id>lixindong.top/14730898296691.html</id>
    <content type="html"><![CDATA[
<p>最近项目组使用findbugs辅助检测代码问题，其中一个问题提到了Integer对象的值比较问题。虽然心里很清楚，java语言类对象的双等号操作符默认比较的是对象的地址，即是否是同一个对象。可是对于Integer、Long这类基本类型的扩展类，心想存在特殊处理的可能，所以还是查了下资料，主要是解释一些心里的疑惑。</p>

<h2 id="toc_0">疑问?</h2>

<ol>
<li>java 能不能重载+、-、 =、==这些运算符</li>
<li>java的Integer、Long这些类型的==运算符是比较地址还是使用<code>equals</code>的结果</li>
<li>为什么两个值为10的Integer对象，用==比较的结果是true，而两个值为1000的Integer对象的比较结果为false?</li>
</ol>

<h2 id="toc_1">解答！</h2>

<h3 id="toc_2">1. 能不能重载运算符？</h3>

<p>不能。<br/>
有些人疑问，可是String对象可以有形如<code>&quot;hello worl&quot; + &#39;d&#39;</code>的操作，基本运算应该是不支持的。<br/>
这里是因为编译器在编译时处理成了<code>Object s2 = (new StringBuilder(&quot;hello world&quot;)).append(&#39;d&#39;).toString();</code>的形式。</p>

<h3 id="toc_3">2. java的Integer、Long这些类型的==运算符是比较地址还是使用<code>equals</code>的结果?</h3>

<p>比较地址。<br/>
因为不能重载运算符，所以即便是这些特殊的类，依然只能在编译器上动动手脚。</p>

<h3 id="toc_4">3. 为什么两个值为10的Integer对象，用==比较的结果是true，而两个值为1000的Integer对象的比较结果为false?</h3>

<p>Integer为-128~127范围内的对象做了缓存处理。<br/>
<code><br/>
public static Integer valueOf(int i) {<br/>
    if(i &gt;= -128 &amp;&amp; i &lt;= IntegerCache.high)<br/>
        return IntegerCache.cache[i + 128];<br/>
    else<br/>
        return new Integer(i);<br/>
}<br/>
</code><br/>
无论你是使用new Integer(..)还是Integer.valueOf(..)获取对象，<br/>
只要值在-128到127的范围内，拿到的就是缓存好的对象。因此无论是<code>==运算符</code>还是equals()方法，只要值相同，结果都是true。<br/>
而如果你的值在这个范围之外，<code>==</code>必然返回false，equals()方法的返回值依对象的值而定。</p>

<h2 id="toc_5">结论</h2>

<p>无论如何，请使用equals()方法比较大小。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何在Java中避免equals方法的隐藏陷阱]]></title>
    <link href="lixindong.top/14730873130757.html"/>
    <updated>2016-09-05T22:55:13+08:00</updated>
    <id>lixindong.top/14730873130757.html</id>
    <content type="html"><![CDATA[
<p>今天看资料时看到coolshell的这篇文章，获益匪浅，收藏到文库里。</p>

<p>译文原文：<a href="http://coolshell.cn/articles/1051.html">http://coolshell.cn/articles/1051.html</a><br/>
英文原文：<a href="http://www.artima.com/lejava/articles/equality.html">http://www.artima.com/lejava/articles/equality.html</a></p>

<p><strong>译者注</strong> :你可能会觉得Java很简单，Object的equals实现也会非常简单，但是事实并不是你想象的这样，耐心的读完本文，你会发现你对Java了解的是如此的少。如果这篇文章是一份Java程序员的入职笔试，那么不知道有多少人会掉落到这样的陷阱中。原文转自<a href="http://www.artima.com/lejava/articles/equality.html">http://www.artima.com/lejava/articles/equality.html</a> 三位作者都是不同领域的大拿，有兴趣的读者可以从上面这个连接直接去阅读原文。</p>

<p><strong>摘要</strong></p>

<p>本文描述重载equals方法的技术，这种技术即使是具现类的子类增加了字段也能保证equal语义的正确性。</p>

<p>在《Effective Java》的第8项中，Josh Bloch描述了当继承类作为面向对象语言中的等价关系的基础问题，要保证派生类的equal正确性语义所会面对的困难。Bloch这样写到：</p>

<blockquote>
<p><strong>除非你忘记了面向对象抽象的好处，否则在当你继承一个新类或在类中增加了一个值组件时你无法同时保证equal的语义依然正确</strong></p>
</blockquote>

<p>在《Programming in Scala》中的第28章演示了一种方法，这种方法允许即使继承了新类，增加了新的值组件，equal的语义仍然能得到保证。虽然在这本书中这项技术是在使用Scala类环境中，但是这项技术同样可以应用于Java定义的类中。在本文中的描述来自于Programming in Scala中的文字描述，但是代码被我从scala翻译成了Java</p>

<h4 id="toc_0">常见的等价方法陷阱</h4>

<p>java.lang.Object 类定义了equals这个方法，它的子类可以通过重载来覆盖它。不幸的是，在面向对象中写出正确的equals方法是非常困难的。事实上，在研究了大量的Java代码后，2007 paper的作者得出了如下的一个结论：</p>

<blockquote>
<p>几乎所有的equals方法的实现都是错误的！</p>
</blockquote>

<p>这个问题是因为等价是和很多其他的事物相关联。例如其中之一，一个的类型C的错误等价方法可能意味着你无法将这个类型C的对象可信赖的放入到容器中。比如说，你有两个元素elem1和elem2他们都是类型C的对象，并且他们是相等，即<code>elem1.equals(elm2)</code>返回ture。但是，只要这个equals方法是错误的实现，那么你就有可能会看见如下的一些行为：</p>

<pre><code>Set hashSet&lt;C&gt; = new java.util.HashSet&lt;C&gt;();
hashSet.add(elem1);
hashSet.contains(elem2);    // returns false!&lt;/pre&gt;
</code></pre>

<p>当equals重载时，这里有4个会引发equals行为不一致的常见陷阱：</p>

<ol>
<li> 定义了错误的equals方法签名(signature) Defining equals with the wrong signature.</li>
<li> 重载了equals的但没有同时重载hashCode的方法。 Changing equals without also changing hashCode.</li>
<li> 建立在会变化字域上的equals定义。 Defining equals in terms of mutable fields.</li>
<li> 不满足等价关系的equals错误定义 Failing to define equals as an equivalence relation.</li>
</ol>

<p>在剩下的章节中我们将依次讨论这4中陷阱。</p>

<h4 id="toc_1">陷阱1：定义错误equals方法签名(signature)</h4>

<p>考虑为下面这个简单类Point增加一个等价性方法：</p>

<pre><code>public class Point {

    private final int x;
    private final int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    // ...
}
</code></pre>

<p>看上去非常明显，但是按照这种方式来定义equals就是错误的。</p>

<pre><code>// An utterly wrong definition of equals
public boolean equals(Point other) {
  return (this.getX() == other.getX() &amp;&amp; this.getY() == other.getY());
}
</code></pre>

<p>这个方法有什么问题呢？初看起来，它工作的非常完美：</p>

<pre><code>Point p1 = new Point(1, 2);
Point p2 = new Point(1, 2);

Point q = new Point(2, 3);

System.out.println(p1.equals(p2)); // prints true

System.out.println(p1.equals(q)); // prints false
</code></pre>

<p>然而，当我们一旦把这个Point类的实例放入到一个容器中问题就出现了：</p>

<pre><code>import java.util.HashSet;

HashSet&lt;Point&gt; coll = new HashSet&lt;Point&gt;();
coll.add(p1);

System.out.println(coll.contains(p2)); // prints false
</code></pre>

<p>为什么coll中没有包含p2呢？甚至是p1也被加到集合里面，p1和p2是是等价的对象吗？在下面的程序中，我们可以找到其中的一些原因，定义p2a是一个指向p2的对象，但是p2a的类型是Object而非Point类型：</p>

<pre><code>Object p2a = p2;
</code></pre>

<p>现在我们重复第一个比较，但是不再使用p2而是p2a,我们将会得到如下的结果：</p>

<pre><code>System.out.println(p1.equals(p2a)); // prints false
</code></pre>

<p>到底是那里出了了问题？事实上，之前所给出的equals版本并没有覆盖Object类的equals方法，因为他的类型不同。下面是Object的equals方法的定义</p>

<pre><code>public boolean equals(Object other)
</code></pre>

<p>因为Point类中的equals方法使用的是以Point类而非Object类做为参数，因此它并没有覆盖Object中的equals方法。而是一种变化了的重载。在Java中重载被解析为静态的参数类型而非运行期的类型，因此当静态参数类型是Point,Point的equals方法就被调用。然而当静态参数类型是Object时，Object类的equals就被调用。因为这个方法并没有被覆盖，因此它仍然是实现成比较对象标示。这就是为什么虽然p1和p2a具有同样的x,y值，”p1.equals(p2a)”仍然返回了false。这也是会什么HasSet的contains方法返回false的原因，因为这个方法操作的是泛型，他调用的是一般化的Object上equals方法而非Point类上变化了的重载方法equals</p>

<p>一个更好但不完美的equals方法定义如下：</p>

<pre><code>// A better definition, but still not perfect
@Override public boolean equals(Object other) {
    boolean result = false;
    if (other instanceof Point) {
        Point that = (Point) other;
        result = (this.getX() == that.getX() &amp;&amp; this.getY() == that.getY());
    }
    return result;
}
</code></pre>

<p>现在equals有了正确的类型，它使用了一个Object类型的参数和一个返回布尔型的结果。这个方法的实现使用instanceof操作和做了一个造型。它首先检查这个对象是否是一个Point类，如果是，他就比较两个点的坐标并返回结果，否则返回false。</p>

<h4 id="toc_2">陷阱2：重载了equals的但没有同时重载hashCode的方法</h4>

<p>如果你使用上一个定义的Point类进行p1和p2a的反复比较，你都会得到你预期的true的结果。但是如果你将这个类对象放入到HashSet.contains()方法中测试，你就有可能仍然得到false的结果：</p>

<pre><code>Point p1 = new Point(1, 2);
Point p2 = new Point(1, 2);

HashSet&lt;Point&gt; coll = new HashSet&lt;Point&gt;();
coll.add(p1);

System.out.println(coll.contains(p2)); // 打印 false (有可能)
</code></pre>

<p>事实上，这个个结果不是100%的false，你也可能有返回ture的经历。如果你得到的结果是true的话，那么你试试其他的坐标值，最终你一定会得到一个在集合中不包含的结果。导致这个结果的原因是Point重载了equals却没有重载hashCode。</p>

<p>注意上面例子的的容器是一个HashSet，这就意味着容器中的元素根据他们的哈希码被被放入到”哈希桶 hash buckets”中。contains方法首先根据哈希码在哈希桶中查找，然后让桶中的所有元素和所给的参数进行比较。现在，虽然最后一个Point类的版本重定义了equals方法，但是它并没有同时重定义hashCode。因此，hashCode仍然是Object类的那个版本，即：所分配对象的一个地址的变换。所以p1和p2的哈希码理所当然的不同了，甚至是即时这两个点的坐标完全相同。不同的哈希码导致他们具有极高的可能性被放入到集合中不同的哈希桶中。contains方法将会去找p2的哈希码对应哈希桶中的匹配元素。但是大多数情况下，p1一定是在另外一个桶中，因此，p2永远找不到p1进行匹配。当然p2和p2也可能偶尔会被放入到一个桶中，在这种情况下，contains的结果就为true了。</p>

<p>最新一个Point类实现的问题是，它的实现违背了作为Object类的定义的hashCode的语义。</p>

<blockquote>
<p>如果两个对象根据equals(Object)方法是相等的，那么在这两个对象上调用hashCode方法应该产生同样的值</p>
</blockquote>

<p>事实上，在Java中，hashCode和equals需要一起被重定义是众所周知的。此外，hashCode只可以依赖于equals依赖的域来产生值。对于Point这个类来说，下面的的hashCode定义是一个非常合适的定义。</p>

<pre><code>public class Point {

    private final int x;
    private final int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    @Override public boolean equals(Object other) {
        boolean result = false;
        if (other instanceof Point) {
            Point that = (Point) other;
            result = (this.getX() == that.getX() &amp;&amp; this.getY() == that.getY());
        }
        return result;
    }

    @Override public int hashCode() {
        return (41 * (41 + getX()) + getY());
    }

}
</code></pre>

<p>这只是hashCode一个可能的实现。x域加上常量41后的结果再乘与41并将结果在加上y域的值。这样做就可以以低成本的运行时间和低成本代码大小得到一个哈希码的合理的分布(<strong>译者注：</strong>性价比相对较高的做法)。</p>

<p>增加hashCode方法重载修正了定义类似Point类等价性的问题。然而，关于类的等价性仍然有其他的问题点待发现。</p>

<h4 id="toc_3">陷阱3：建立在会变化字段上的equals定义</h4>

<p>让我们在Point类做一个非常微小的变化</p>

<pre><code>public class Point {

    private int x;
    private int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    public void setX(int x) { // Problematic
        this.x = x;
    }

    public void setY(int y) {
        this.y = y;
    }

    @Override public boolean equals(Object other) {
        boolean result = false;
        if (other instanceof Point) {
            Point that = (Point) other;
            result = (this.getX() == that.getX() &amp;&amp; this.getY() == that.getY());
        }
        return result;
    }

    @Override public int hashCode() {
        return (41 * (41 + getX()) + getY());
    }
}
</code></pre>

<p>唯一的不同是x和y域不再是final，并且两个set方法被增加到类中来，并允许客户改变x和y的值。equals和hashCode这个方法的定义现在是基于在这两个会发生变化的域上，因此当他们的域的值改变时，结果也就跟着改变。因此一旦你将这个point对象放入到集合中你将会看到非常神奇的效果。</p>

<pre><code>Point p = new Point(1, 2);

HashSet&lt;Point&gt; coll = new HashSet&lt;Point&gt;();
coll.add(p);

System.out.println(coll.contains(p)); // 打印 true
</code></pre>

<p>现在如果你改变p中的一个域，这个集合中还会包含point吗，我们将拭目以待。</p>

<pre><code>p.setX(p.getX() + 1);

System.out.println(coll.contains(p)); // (有可能)打印 false
</code></pre>

<p>看起来非常的奇怪。p去那里去了？如果你通过集合的迭代器来检查p是否包含，你将会得到更奇怪的结果。</p>

<pre><code>Iterator&lt;Point&gt; it = coll.iterator();
boolean containedP = false;
while (it.hasNext()) {
    Point nextP = it.next();
    if (nextP.equals(p)) {
        containedP = true;
        break;
    }
}

System.out.println(containedP); // 打印 true
</code></pre>

<p>结果是，集合中不包含p，但是p在集合的元素中！到底发生了什么！当然，所有的这一切都是在x域的修改后才发生的，p最终的的hashCode是在集合coll错误的哈希桶中。即，原始哈希桶不再有其新值对应的哈希码。换句话说，p已经在集合coll的是视野范围之外，虽然他仍然属于coll的元素。</p>

<p>从这个例子所得到的教训是，当equals和hashCode依赖于会变化的状态时，那么就会给用户带来问题。如果这样的对象被放入到集合中，用户必须小心，不要修改这些这些对象所依赖的状态，这是一个小陷阱。如果你需要根据对象当前的状态进行比较的话，你应该不要再重定义equals，应该起其他的方法名字而不是equals。对于我们的Point类的最后的定义，我们最好省略掉hashCode的重载，并将比较的方法名命名为equalsContents，或其他不同于equals的名字。那么Point将会继承原来默认的equals和hashCode的实现，因此当我们修改了x域后p依然会呆在其原来在容器中应该在位置。</p>

<h4 id="toc_4">陷阱4：不满足等价关系的equals错误定义</h4>

<p>Object中的equals的规范阐述了equals方法必须实现在非null对象上的等价关系：</p>

<ul>
<li>  自反原则：对于任何非null值X,表达式x.equals(x)总返回true。</li>
<li>  等价性：对于任何非空值x和y，那么当且仅当y.equals(x)返回真时，x.equals(y)返回真。</li>
<li>  传递性：对于任何非空值x,y,和z，如果x.equals(y)返回真，且y.equals(z)也返回真，那么x.equals(z)也应该返回真。</li>
<li>  一致性：对于非空x,y，多次调用x.equals(y)应该一致的返回真或假。提供给equals方法比较使用的信息不应该包含改过的信息。</li>
<li>  对于任何非空值x,x.equals(null)应该总返回false.</li>
</ul>

<p>Point类的equals定义已经被开发成了足够满足equals规范的定义。然而，当考虑到继承的时候，事情就开始变得非常复杂起来。比如说有一个Point的子类ColoredPoint，它比Point多增加了一个类型是Color的color域。假设Color被定义为一个枚举类型：</p>

<pre><code>public enum Color {
    RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET;
}
</code></pre>

<p>ColoredPoint重载了equals方法，并考虑到新加入color域，代码如下：</p>

<pre><code>public class ColoredPoint extends Point { // Problem: equals not symmetric

    private final Color color;

    public ColoredPoint(int x, int y, Color color) {
        super(x, y);
        this.color = color;
    }

    @Override public boolean equals(Object other) {
        boolean result = false;
        if (other instanceof ColoredPoint) {
            ColoredPoint that = (ColoredPoint) other;
            result = (this.color.equals(that.color) &amp;&amp; super.equals(that));
        }
        return result;
    }
}
</code></pre>

<p>这是很多程序员都有可能写成的代码。注意在本例中，类ColoredPointed不需要重载hashCode，因为新的ColoredPoint类上的equals定义，严格的重载了Point上equals的定义。hashCode的规范仍然是有效，如果两个着色点(colored point)相等，其坐标必定相等，因此它的hashCode也保证了具有同样的值。</p>

<p>对于ColoredPoint类自身对象的比较是没有问题的，但是如果使用ColoredPoint和Point混合进行比较就要出现问题。</p>

<pre><code>Point p = new Point(1, 2);

ColoredPoint cp = new ColoredPoint(1, 2, Color.RED);

System.out.println(p.equals(cp)); // 打印真 true

System.out.println(cp.equals(p)); // 打印假 false
</code></pre>

<p>“p等价于cp”的比较这个调用的是定义在Point类上的equals方法。这个方法只考虑两个点的坐标。因此比较返回真。在另外一方面，“cp等价于p”的比较这个调用的是定义在ColoredPoint类上的equals方法，返回的结果却是false，这是因为p不是ColoredPoint，所以equals这个定义违背了对称性。</p>

<p>违背对称性对于集合来说将导致不可以预期的后果，例如：</p>

<pre><code>Set&lt;Point&gt; hashSet1 = new java.util.HashSet&lt;Point&gt;();
hashSet1.add(p);
System.out.println(hashSet1.contains(cp));    // 打印 false

Set&lt;Point&gt; hashSet2 = new java.util.HashSet&lt;Point&gt;();
hashSet2.add(cp);
System.out.println(hashSet2.contains(p));    // 打印 true
</code></pre>

<p>因此虽然p和cp是等价的，但是contains测试中一个返回成功，另外一个却返回失败。</p>

<p>你如何修改equals的定义，才能使得这个方法满足对称性？本质上说有两种方法，你可以使得这种关系变得更一般化或更严格。更一般化的意思是这一对对象，a和b，被用于进行对比，无论是a比b还是b比a 都返回true，下面是代码：</p>

<pre><code>public class ColoredPoint extends Point { // Problem: equals not transitive

    private final Color color;

    public ColoredPoint(int x, int y, Color color) {
        super(x, y);
        this.color = color;
    }

    @Override public boolean equals(Object other) {
        boolean result = false;
        if (other instanceof ColoredPoint) {
            ColoredPoint that = (ColoredPoint) other;
            result = (this.color.equals(that.color) &amp;&amp; super.equals(that));
        }
        else if (other instanceof Point) {
            Point that = (Point) other;
            result = that.equals(this);
        }
        return result;
    }
}
</code></pre>

<p>在ColoredPoint中的equals的新定义比老定义中检查了更多的情况:如果对象是一个Point对象而不是ColoredPoint，方法就转变为Point类的equals方法调用。这个所希望达到的效果就是equals的对称性，不管”cp.equals(p)”还是”p.equals(cp)”的结果都是true。然而这种方法，equals的规范还是被破坏了，现在的问题是这个新等价性不满足传递性。考虑下面的一段代码实例，定义了一个点和这个点上上两种不同颜色点：</p>

<pre><code>ColoredPoint redP = new ColoredPoint(1, 2, Color.RED);
ColoredPoint blueP = new ColoredPoint(1, 2, Color.BLUE);
</code></pre>

<p>redP等价于p，p等价于blueP</p>

<pre><code>System.out.println(redP.equals(p)); // prints true

System.out.println(p.equals(blueP)); // prints true
</code></pre>

<p>然而，对比redP和blueP的结果是false:</p>

<pre><code>System.out.println(redP.equals(blueP)); // 打印 false
</code></pre>

<p>因此，equals的传递性就被违背了。</p>

<p>使equals的关系更一般化似乎会将我们带入到死胡同。我们应该采用更严格化的方法。一种更严格化的equals方法是认为不同类的对象是不同的。这个可以通过修改Point类和ColoredPoint类的equals方法来达到。你能增加额外的比较来检查是否运行态的这个Point类和那个Point类是同一个类，就像如下所示的代码一样：</p>

<pre><code>// A technically valid, but unsatisfying, equals method
public class Point {

    private final int x;
    private final int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    @Override public boolean equals(Object other) {
        boolean result = false;
        if (other instanceof Point) {
            Point that = (Point) other;
            result = (this.getX() == that.getX() &amp;&amp; this.getY() == that.getY()
                    &amp;&amp; this.getClass().equals(that.getClass()));
        }
        return result;
    }

    @Override public int hashCode() {
        return (41 * (41 + getX()) + getY());
    }
}
</code></pre>

<p>你现在可以将ColoredPoint类的equals实现用回刚才那个不满足对称性要的equals实现了。</p>

<pre><code>public class ColoredPoint extends Point { // 不再违反对称性需求

    private final Color color;

    public ColoredPoint(int x, int y, Color color) {
        super(x, y);
        this.color = color;
    }

    @Override public boolean equals(Object other) {
        boolean result = false;
        if (other instanceof ColoredPoint) {
            ColoredPoint that = (ColoredPoint) other;
            result = (this.color.equals(that.color) &amp;&amp; super.equals(that));
        }
        return result;
    }
}
</code></pre>

<p>这里，Point类的实例只有当和另外一个对象是同样类，并且有同样的坐标时候，他们才被认为是相等的，即意味着 .getClass()返回的是同样的值。这个新定义的等价关系满足了对称性和传递性因为对于比较对象是不同的类时结果总是false。所以着色点(colored point)永远不会等于点(point)。通常这看起来非常合理，但是这里也存在着另外一种争论——这样的比较过于严格了。</p>

<p>考虑我们如下这种稍微的迂回的方式来定义我们的坐标点(1,2)</p>

<pre><code>Point pAnon = new Point(1, 1) {
    @Override public int getY() {
        return 2;
    }
};
</code></pre>

<p>pAnon等于p吗？答案是假，因为p和pAnon的java.lang.Class对象不同。p是Point，而pAnon是Point的一个匿名派生类。但是，非常清晰的是pAnon的确是在坐标1，2上的另外一个点。所以将他们认为是不同的点是没有理由的。</p>

<h4 id="toc_5">canEqual 方法</h4>

<p>到此，我们看其来似乎是遇到阻碍了，存在着一种正常的方式不仅可以在不同类继承层次上定义等价性，并且保证其等价的规范性吗？事实上，的确存在这样的一种方法，但是这就要求除了重定义equals和hashCode外还要另外的定义一个方法。基本思路就是在重载equals(和hashCode)的同时，它应该也要要明确的声明这个类的对象永远不等价于其他的实现了不同等价方法的超类的对象。为了达到这个目标，我们对每一个重载了equals的类新增一个方法canEqual方法。这个方法的方法签名是：</p>

<pre><code>public boolean canEqual(Object other)
</code></pre>

<p>如果other 对象是canEquals(重)定义那个类的实例时，那么这个方法应该返回真，否则返回false。这个方法由equals方法调用，并保证了两个对象是可以相互比较的。下面Point类的新的也是最终的实现：</p>

<pre><code>public class Point {

    private final int x;
    private final int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    @Override public boolean equals(Object other) {
        boolean result = false;
        if (other instanceof Point) {
            Point that = (Point) other;
            result =(that.canEqual(this) &amp;&amp; this.getX() == that.getX() &amp;&amp; this.getY() == that.getY());
        }
        return result;
    }

    @Override public int hashCode() {
        return (41 * (41 + getX()) + getY());
    }
    public boolean canEqual(Object other) {
        return (other instanceof Point);
    }

}
</code></pre>

<p>这个版本的Point类的equals方法中包含了一个额外的需求，通过canEquals方法来决定另外一个对象是否是是满足可以比较的对象。在Point中的canEqual宣称了所有的Point类实例都能被比较。</p>

<p>下面是ColoredPoint相应的实现</p>

<pre><code>public class ColoredPoint extends Point { // 不再违背对称性

    private final Color color;

    public ColoredPoint(int x, int y, Color color) {
        super(x, y);
        this.color = color;
    }

    @Override public boolean equals(Object other) {
        boolean result = false;
        if (other instanceof ColoredPoint) {
            ColoredPoint that = (ColoredPoint) other;
            result = (that.canEqual(this) &amp;&amp; this.color.equals(that.color) &amp;&amp; super.equals(that));
        }
        return result;
    }

    @Override public int hashCode() {
        return (41 * super.hashCode() + color.hashCode());
    }

    @Override public boolean canEqual(Object other) {
        return (other instanceof ColoredPoint);
    }
}
</code></pre>

<p>在上显示的新版本的Point类和ColoredPoint类定义保证了等价的规范。等价是对称和可传递的。比较一个Point和ColoredPoint类总是返回false。因为点p和着色点cp,“p.equals(cp)返回的是假。并且，因为cp.canEqual(p)总返回false。相反的比较，cp.equals(p)同样也返回false，由于p不是一个ColoredPoint，所以在ColoredPoint的equals方法体内的第一个instanceof检查就失败了。</p>

<p>另外一个方面，不同的Point子类的实例却是可以比较的，同样没有重定义等价性方法的类也是可以比较的。对于这个新类的定义，p和pAnon的比较将总返回true。下面是一些例子：</p>

<pre><code>Point p = new Point(1, 2);

ColoredPoint cp = new ColoredPoint(1, 2, Color.INDIGO);

Point pAnon = new Point(1, 1) {
    @Override public int getY() {
        return 2;
    }
};

Set&lt;Point&gt; coll = new java.util.HashSet&lt;Point&gt;();
coll.add(p);

System.out.println(coll.contains(p)); // 打印 true

System.out.println(coll.contains(cp)); // 打印 false

System.out.println(coll.contains(pAnon)); // 打印 true
</code></pre>

<p>这些例子显示了如果父类在equals的实现定义并调用了canEquals，那么开发人员实现的子类就能决定这个子类是否可以和它父类的实例进行比较。例如ColoredPoint，因为它以”一个着色点永远不可以等于普通不带颜色的点重载了” canEqual，所以他们就不能比较。但是因为pAnon引用的匿名子类没有重载canEqual,因此它的实例就可以和Point的实例进行对比。</p>

<p>canEqual方法的一个潜在的争论是它是否违背了Liskov替换准则(LSP)。例如，通过比较运行态的类来实现的比较技术(<strong>译者注：</strong> canEqual的前一版本，使用.getClass()的那个版本)，将导致不能定义出一个子类，这个子类的实例可以和其父类进行比较，因此就违背了LSP。这是因为，LSP原则是这样的，在任何你能使用父类的地方你都可以使用子类去替换它。在之前例子中，虽然cp的x,y坐标匹配那些在集合中的点，然而”coll.contains(cp)”仍然返回false，这看起来似乎违背得了LSP准则，因为你不能这里能使用Point的地方使用一个ColoredPointed。但是我们认为这种解释是错误的，因为LSP原则并没有要求子类和父类的行为一致，而仅要求其行为能一种方式满足父类的规范。</p>

<p>通过比较运行态的类来编写equals方法(<strong>译者注：</strong> canEqual的前一版本，使用.getClass()的那个版本)的问题并不是违背LSP准则的问题，但是它也没有为你指明一种创建派生类的实例能和父类实例进行对比的的方法。例如，我们使用这种运行态比较的技术在之前的”coll.contains(pAnon)”将会返回false，并且这并不是我们希望的。相反我们希望“coll.contains(cp)”返回false，因为通过在ColoredPoint中重载的equals，我基本上可以说，一个在坐标1，2上着色点和一个坐标1，2上的普通点并不是一回事。然而，在最后的例子中，我们能传递Point两种不同的子类实例到集合中contains方法，并且我们能得到两个不同的答案，并且这两个答案都正确。</p>

<p><strong>–全文完–</strong></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android GPS定位欺骗(模拟定位)的两种方式]]></title>
    <link href="lixindong.top/14720509840810.html"/>
    <updated>2016-08-24T23:03:04+08:00</updated>
    <id>lixindong.top/14720509840810.html</id>
    <content type="html"><![CDATA[
<p>前段时间发布的手游PokemonGo相信大家都有耳闻，而因为这个游戏在国内的坐标遭到了封锁，很多科学游戏方法也陆续涌现。好不热闹。<br/>
那其实，PokemonGo最初的版本，在大陆是可以通过简单的vpn+gps欺骗进行游戏的。<br/>
不过很快地，在新的版本更新中就封锁了这一方式。</p>

<p>而对Android系统使用GPS欺骗，应用场景也绝不只是这一个游戏而已。所以我今天来简单介绍一下可使用的几种方式。</p>

<blockquote>
<p>控制噪声的方式有三种：防止噪声产生，阻断噪声传播和防止噪声进入耳朵</p>
</blockquote>

<p>相对应的，</p>

<blockquote>
<p>修改GPS定位结果的三种途径： 编译时修改NLP结果，运行时修改LocationManager结果，从应用获取到的结果修改。</p>
</blockquote>

<h3 id="toc_0">1. 编译时修改NLP结果</h3>

<p>难度系数：五颗星<br/>
建议：想都别想<br/>
大概思路：修改nlp部分源码，重编系统</p>

<h3 id="toc_1">2. 运行时修改LocationManager结果</h3>

<p>这个分两类：</p>

<blockquote>
<p><strong>一类</strong>： 使用android自带的调试api，模拟gps provider的结果。</p>
</blockquote>

<pre><code>LocationManager.setTestProviderLocation(Provider, Location);
</code></pre>

<p>优点：简单，无需root<br/>
缺点：不稳定，特征明显，容易按特征嗅探到（有反作弊机制的游戏基本都能查出来），需要打开开发者的允许模拟位置选项</p>

<blockquote>
<p><strong>第二类</strong>: 使用xposed,传说中的android神器，用它对app_process进行注入。</p>
</blockquote>

<p>有什么用呢，就是你可以放个钩子，英文名叫hook。这个钩子能知道你系统里的每个应用什么时候调用了哪个函数，还能修改对应的这个函数。<br/>
说到这就懂了吧。比如你猜测对应app会使用LocationManager.getLastKnownLocation的结果。然后你用xposed把内存里的这个函数返回值改成 <code>纬度 N 39.832670° 东经 E116.460370°</code>，然后调用这个函数的程序看到的记过就是你修改之后的结果。<br/>
具体代码看这里吧（非本人repo，只是找了个简单易懂的demo）<br/>
<a href="https://github.com/YiuChoi/FakeGps/tree/master/app/src/main/java/name/caiyao/fakegps/hook">FakeGPS demo</a></p>

<p>优点：稳定，难以被反查<br/>
缺点：需要root</p>

<h3 id="toc_2">3. 对想欺骗的app反编译，修改结果</h3>

<p>该怎么做看标题就明白了。<br/>
步骤就是<br/>
1. 反编译<br/>
2. 找到所有使用了定位结果的位置<br/>
3. 修改结果<br/>
4. 重新打包</p>

<p>这个方式的优缺点也很明显。<br/>
优点： 无需root，稳定性强（前提是找准入口）<br/>
缺点： 技术水平要求高。根据应用复杂程度、混淆、安全策略等不同，难度差异较大。难易程度包括很多内容，包括混淆部分、入口寻找、签名验证等。 我也不熟啊，感兴趣的同学请自行深入学习吧。</p>

<p>————————</p>

<p>3类4种欺骗方式，各位看官收好。</p>

<p>以上。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[android - LinearLayout RelativeLayout在布局时优先选择谁？有何区别？]]></title>
    <link href="lixindong.top/14720509627845.html"/>
    <updated>2016-08-24T23:02:42+08:00</updated>
    <id>lixindong.top/14720509627845.html</id>
    <content type="html"><![CDATA[
<p>很多初接触android的同学在布局时都会有这样一个疑问：</p>

<blockquote>
<p>这个布局的父亲用LinearLayout和RelativeLayout都可以，我用哪个更合适呢？</p>
</blockquote>

<p>有些同学可能就开始权量了，RelativeLayout更灵活，用这个吧。但是感觉LinearLayout更方便啊，自动帮我把这几个View分布开了，不会一开始就挤在一块。</p>

<p>其实呢，随着项目的进展，布局会发生调整，这是再自然不过的事情。</p>

<blockquote>
<p>不要让自己这些『主观』的思考拖慢进度。</p>
</blockquote>

<p>今天我从数据上来说下在面临这种情况（两者都可选择）时，应如何选择。</p>

<p><strong>注: 当然，很多情况会有其它更好的选择，我这里仅就这两者进行对比。</strong></p>

<blockquote>
<p>从效率的角度考虑，选取渲染速度更快的那个。</p>
</blockquote>

<p>我们知道一个View的绘制包括三个步骤：<br/>
1. 测量 measure<br/>
2. 布局 layout<br/>
3. 绘制 draw</p>

<p>这三个哪个拖后腿都会影响渲染效率，我们就来看看使用不同的布局时，这三者之间的差距。</p>

<table>
<thead>
<tr>
<th></th>
<th>子View</th>
<th>父View</th>
</tr>
</thead>

<tbody>
<tr>
<td>父View使用LinearLayout</td>
<td><img src="http://upload-images.jianshu.io/upload_images/25769-ad4a99485588a741.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="linear_child.png"/></td>
<td><img src="http://upload-images.jianshu.io/upload_images/25769-c2a9998a2d24bc74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="linear_parent.png"/></td>
</tr>
<tr>
<td>父View使用RelativeLayout</td>
<td><img src="http://upload-images.jianshu.io/upload_images/25769-0d2ff6157d6133e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="relative_child.png"/></td>
<td><img src="http://upload-images.jianshu.io/upload_images/25769-4c1f5807cd35172d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="relative_parent.png"/></td>
</tr>
</tbody>
</table>

<p>这里我们主要关注 <strong>Measure</strong> 时间。<br/>
通过对比我们可以看到，父View使用LinearLayout时，父亲和孩子的Measure时间是相差无几的。<br/>
而父View使用RelativeLayout时，父亲几乎是孩子的两倍。</p>

<blockquote>
<p>RelativeLayout 的子View经常会被measure两次。</p>
</blockquote>

<h3 id="toc_0">结论</h3>

<ol>
<li>两者都可使用，并且层数不受影响的前提下，尽量使用LinearLayout.</li>
<li>若是层数受影响，优先考虑层数少的。(这点会在以后的文章中谈到)</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[带阴影的TextView 淡入淡出动画异常，显示多余的阴影]]></title>
    <link href="lixindong.top/14720508913010.html"/>
    <updated>2016-08-24T23:01:31+08:00</updated>
    <id>lixindong.top/14720508913010.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">1. 问题</h4>

<p>带阴影的TextView 淡入淡出动画异常，有多余的阴影</p>

<h4 id="toc_1">2. 复现步骤</h4>

<ol>
<li>TextView 设置阴影</li>
<li>对TextView设置的alpha值设置 ObjectAnimator</li>
<li>观察</li>
</ol>

<h4 id="toc_2">3. 上图</h4>

<table>
<thead>
<tr>
<th>TextView底部有多余阴影</th>
<th>动画正常</th>
</tr>
</thead>

<tbody>
<tr>
<td><img src="http://upload-images.jianshu.io/upload_images/25769-6ba639edeab70edb.jpg?imageMogr2/auto-orient/strip" alt=""/></td>
<td><img src="http://upload-images.jianshu.io/upload_images/25769-57053d376b7c5fd8.jpg?imageMogr2/auto-orient/strip" alt=""/></td>
</tr>
</tbody>
</table>

<h4 id="toc_3">4. 原因</h4>

<ol>
<li>硬件加速并非对所有2D图形的支持都很好，处理alpha相关的事件时需尤为注意。</li>
<li>并非所有方法都有做应对处理。</li>
</ol>

<h4 id="toc_4">5. 解决方案</h4>

<ol>
<li>对相应的View或Activity或Application关闭硬件加速。</li>
<li>使用其他替代方法实现动画。这就要看具体方法的实现了。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微博自动发贴，简单却不容易被注意到的反爬方式]]></title>
    <link href="lixindong.top/14705728845498.html"/>
    <updated>2016-08-07T20:28:04+08:00</updated>
    <id>lixindong.top/14705728845498.html</id>
    <content type="html"><![CDATA[
<p>移动端登录后移步 <a href="http://m.weibo.cn/mblog">http://m.weibo.cn/mblog</a> 页面发贴，正常思路是：填写消息-&gt;其它选项-&gt;点击发送。</p>

<pre><code>tv_msg.send_keys(&quot;msg&quot;)
btn_send.click()
</code></pre>

<p>仔细看下细节，会发现，发送按钮一开始是disable的，输入消息后才会变成enable。<br/>
所以按理说，代码确实没有问题。可是执行结果是最终停留在这个页面，而且send按钮<strong>并没有</strong>变成可用的橙色。</p>

<p>测试最后发现，msg输入后，send并不会立即改变状态，而是有一个很小的延迟时间。而因为机器的执行速度极快，导致在send状态改变前，已经执行了click动作。所以发送动作没有如期进行。</p>

<p>在其中加入一点delay解决问题。</p>

<pre><code>tv_msg.send_keys(&quot;msg&quot;)
time.sleep(0.1)
btn_send.click()
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用 Python + Selenium 实现对页面的指定元素截图(可截长图元素)]]></title>
    <link href="lixindong.top/14705395849188.html"/>
    <updated>2016-08-07T11:13:04+08:00</updated>
    <id>lixindong.top/14705395849188.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">对WebElement截图</h2>

<p>WebDriver.Chrome自带的方法只能对当前窗口截屏，且不能指定特定元素。若是需要截取特定元素或是窗口超过了一屏，就只能另辟蹊径了。<br/>
WebDriver.PhantomJS自带的方法支持对整个网页截屏。<br/>
下面提供几种思路。</p>

<h4 id="toc_1">方式一</h4>

<blockquote>
<p>针对WebDriver.Chrome</p>
</blockquote>

<p>通过WebDriver的js脚本注入功能，曲线救国。<br/>
1. 注入第三方html转canvas的js库(见下方推荐)<br/>
2. 获取元素html源码<br/>
3. 将html转换为canvas<br/>
4. 下载canvas</p>

<p><strong>优点</strong>: 截取长图容易实现<br/>
<strong>缺点</strong>: 加载第三方库耗费时间，转换原理请参考这篇文章:<br/>
<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Drawing_DOM_objects_into_a_canvas">将 DOM 对象绘制到 canvas 中</a></p>

<h4 id="toc_2">方式二</h4>

<blockquote>
<p>针对WebDriver.Chrome</p>
</blockquote>

<p>截取全图，自行裁剪、拼接<br/>
1. 获取元素位置、大小<br/>
2. 获取窗口大小<br/>
3. 截取包含元素的窗口<br/>
4. 进行相应的裁剪和拼接。</p>

<p>具体算法思路很清晰，但需要注意的细节较多。这里就不在赘述。示例代码请移步: <br/>
<a href="https://github.com/auv1107/PythonSpiderLibs">[Github]PythonSpiderLibs</a></p>

<p><strong>优点</strong>: 不需太多js工作，python+少量js代码即可完成<br/>
<strong>缺点</strong>: 拼接等工作会被WebDriver的实现差异、图片加载速度等因素影响，需多加注意。 在保证截图质量的情况下，速度较慢</p>

<h4 id="toc_3">方式三</h4>

<blockquote>
<p>针对WebDriver.PhantomJS<br/>
由于接口实现的差异，PhantomJS相比于Chrome，可以截取到整个网页。所以获取指定元素的截图也就简单很多</p>
</blockquote>

<ol>
<li>截取网页全图</li>
<li>裁剪指定元素</li>
</ol>

<pre><code>driver = webdriver.Chrome()
driver.get(&#39;http://stackoverflow.com/&#39;)
driver.save_screenshot(&#39;screenshot.png&#39;)

left = element.location[&#39;x&#39;]
top = element.location[&#39;y&#39;]
right = element.location[&#39;x&#39;] + element.size[&#39;width&#39;]
bottom = element.location[&#39;y&#39;] + element.size[&#39;height&#39;]

im = Image.open(&#39;screenshot.png&#39;) 
im = im.crop((left, top, right, bottom))
im.save(&#39;screenshot.png&#39;)
</code></pre>

<p><strong>优点</strong>: 实现简单<br/>
<strong>缺点</strong>: 对于高度太高的页面会导致文件过大，处理会有问题，我测试的最大图片尺寸是12.8M。</p>

<h4 id="toc_4">解决图片加载不完整的问题</h4>

<p>参考: <a href="http://codingpy.com/article/take-screenshot-of-web-page-using-selenium/">利用 Python + Selenium 自动化快速截图</a></p>

<p>我们先在首页上执行一段 JavaScript 脚本，将页面的滚动条拖到最下方，然后再拖回顶部，最后才截图。这样可以解决像上面那种按需加载图片的情况。</p>

<pre><code>from selenium import webdriver
import time


def take_screenshot(url, save_fn=&quot;capture.png&quot;):
    browser = webdriver.Firefox() # Get local session of firefox
    browser.set_window_size(1200, 900)
    browser.get(url) # Load page
    browser.execute_script(&quot;&quot;&quot;
        (function () {
            var y = 0;
            var step = 100;
            window.scroll(0, 0);

            function f() {
                if (y &lt; document.body.scrollHeight) {
                    y += step;
                    window.scroll(0, y);
                    setTimeout(f, 100);
                } else {
                    window.scroll(0, 0);
                    document.title += &quot;scroll-done&quot;;
                }
            }

            setTimeout(f, 1000);
        })();
    &quot;&quot;&quot;)

    for i in xrange(30):
        if &quot;scroll-done&quot; in browser.title:
            break
        time.sleep(10)

    browser.save_screenshot(save_fn)
    browser.close()


if __name__ == &quot;__main__&quot;:

    take_screenshot(&quot;http://codingpy.com&quot;)

</code></pre>

<h2 id="toc_5">不同wewbdriver对某些方法的实现不同</h2>

<p>Chrome和PhantomJS 的接口差异<br/>
抓知乎时的坑，<br/>
1. Chrome用<code>WebElement.text</code>可以正常得到值，用PhantomJS只能用 <code>WebElement.get_attribute(&#39;innerHTML&#39;)</code><br/>
2. WebDriver.Chrome截图只能截当前屏幕区域。WebDriver.PhantomJS截图可以获取整个页面的长图。</p>

<p>其它还有一些坑等待发现</p>

<h2 id="toc_6">推荐</h2>

<ol>
<li><a href="http://html2canvas.hertzen.com/documentation.html">html2canvas库</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Drawing_DOM_objects_into_a_canvas">将 DOM 对象绘制到 canvas 中</a></li>
<li><a href="http://codingpy.com/article/take-screenshot-of-web-page-using-selenium/">利用 Python + Selenium 自动化快速截图</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[技术资料]]></title>
    <link href="lixindong.top/14705318101263.html"/>
    <updated>2016-08-07T09:03:30+08:00</updated>
    <id>lixindong.top/14705318101263.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">文档</h2>

<p><a href="https://pillow.readthedocs.io/en/3.3.x/">Pillow(PIL Fork)</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android应用横竖屏切换的两种方式，从表现上看最大的区别]]></title>
    <link href="lixindong.top/14701507519730.html"/>
    <updated>2016-08-02T23:12:31+08:00</updated>
    <id>lixindong.top/14701507519730.html</id>
    <content type="html"><![CDATA[
<p>我们知道android应用更改屏幕方向有两种方式，对应两种过程，一是销毁重建，二是设置onConfigurationChanged。在其中做改变方向的处理。</p>

<p>很久前我们的测试同学给计算器应用报了一个bug，说应用旋转到横屏后锁屏，再解锁。此时应用会先回到竖屏，再转换到横屏(图一)。正确的表现应该和浏览器的表现一样(图二),解锁后直接进入横屏。<br/>
<img src="http://i.imgur.com/m9kqNuh.gif" alt="图一，表现错误，使用销毁重建的方式"/><br/>
<img src="http://i.imgur.com/jsswjwK.gif" alt="图二，表现正确，使用onConfigurationChanged"/></p>

<p>百思不得其解。<br/>
后来解一个性能相关的bug，很巧地把原来销毁重建的方式，改成了onConfigurationChanged处理。无意间解了这个搁置很久的问题。</p>

<p>根据systrace的结果，推测可能的原因如下。<br/>
1. 销毁重建，其间会进行目标activity的销毁、重建以及其它系统调用。这一系列动作不能在一帧内完成，导致解锁时能看到竖屏切换到横屏的动作。<br/>
2. onConfigurationChanged，横竖屏切换其间只执行这一个函数，其中只有layout的MLD操作，这一系列动作在短时间内完成，因此我们看到的也就直接进入和横屏。<br/>
3. 可能有其它activity管理之间的原因，暂不清楚。知道的请不吝赐教。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[谈谈爬虫-模拟登录思路]]></title>
    <link href="lixindong.top/14698088043297.html"/>
    <updated>2016-07-30T00:13:24+08:00</updated>
    <id>lixindong.top/14698088043297.html</id>
    <content type="html"><![CDATA[
<p>最近在做的sideproject，需要网络上的文章数据。于是顺便学习了下爬虫技术，也算是有些心得体会。写下来分享给刚入坑的新人。</p>

<h2 id="toc_0">怎么理解模拟登录？</h2>

<p>怎么理解模拟登录？<br/>
把这句话补全就是： 怎么(让机器)模拟(人在浏览器上的行为)登录(指定的网站)。<br/>
那么这个问题实际上问的是： 人通过浏览器登录网站时，浏览器为我们做了哪些事情。<br/>
那么我们需要做的只有：写一个脚本，让这个脚本模拟浏览器的行为，做我们希望它做的事情。</p>

<p>有兴趣参考:<br/>
 <a href="https://www.zhihu.com/question/34873227">当在浏览器地址栏输入一个URL后回车，将会发生的事情？</a></p>

<p><strong>那么</strong>，<br/>
人类在登录时做了哪些事情呢，很简单：<br/>
1. 打开登录页面<br/>
2. 输入用户名密码，有时可能还有验证码，各种各样的验证码<br/>
3. 点击登录<br/>
4. 等待浏览器自动跳转</p>

<p>只要你稍微懂一点html语言，就应该能分析个八九不离十。<br/>
机器人怎么做呢：<br/>
两种方式：</p>

<p><strong>方式一</strong>：<br/>
需要使用虚拟的浏览器引擎。<br/>
优点: 适合几乎所有的网站登录，可以人为输入验证码<br/>
缺点: 速度较慢<br/>
1. 请求登录页面的url，比如微博的(<a href="https://passport.weibo.cn/signin/login">https://passport.weibo.cn/signin/login</a>)<br/>
2. 分析html中的表单数据<br/>
2.1 找到输入用户名、密码的输入框<br/>
2.2 把输入框的text域替换成自己的用户名密码<br/>
3. 模拟点击提交按钮</p>

<p><strong>方式二</strong>：<br/>
分析登录信息提交方式，一般就是表单<br/>
优点: 轻量，速度快<br/>
缺点: 局限性大，对技术要求高，对验证码机制需要做针对的破解<br/>
1. 使用浏览器的调试模式查看网页<br/>
2. 检查是否使用表单提交<br/>
3. 点击登录按钮，查看发送的请求数据。主要查看参数有无加密验证或其它隐藏信息。<br/>
4. 使用分析结果进行请求操作</p>

<p>对于一般用户，所有的非特殊性需求都可以使用方式一进行完成。<br/>
若非是为了学习，推荐方式一。</p>

<p>技术资料请参考:<br/>
<a href="http://cuiqingcai.com/1052.html">Python爬虫学习系列教程</a>(推荐)<br/>
<a href="http://www.voidcn.com/blog/eastmount/article/p-5954929.html">[Python爬虫] Selenium爬取新浪微博移动端热点话题及评论 (下)</a></p>

<h2 id="toc_1">如何让脚本的行为看起来像人？</h2>

<p><strong>为什么要像人</strong><br/>
因为很多服务器会使用一些反爬技术拒绝爬虫软件访问。</p>

<p><strong>哪些东西让你看起来像人，哪些不像人</strong><br/>
像人，其实可以分为两点。<br/>
一类是看请求数据，是否符合是浏览器发出的正常数据，比如header内容。<br/>
一类是看行为模式，发送请求对象的行为更像人类还是机器人，比如请求的频率。</p>

<p>不像人，和上面对应。<br/>
从请求数据上看，你没说明user-agent,我就可以认为你是非法侵入。你没有带着我之前给你的饼干(cookie)来，我也可以拒绝你。<br/>
从行为模式上，同一个ip访问的频率过高，短时间内流量异常，都可以作为非人类处理。</p>

<h2 id="toc_2">结合反爬技术</h2>

<ol>
<li>需要登录用cookie</li>
<li>ip限制加代理</li>
<li>用user-agent告诉对方你是浏览器</li>
<li>服务器限制访问频率，加延迟</li>
<li>ajax异步加载，使用js引擎或者人工分析</li>
<li>redirect，最简单的方式虚拟内核＋延迟</li>
<li>验证码，虚拟内核</li>
</ol>

<h2 id="toc_3">如何找切入点？</h2>

<p>什么是好的登录页面？<br/>
没有验证码，非ajax异步加载。<br/>
不一定局限于pc端网页，app端、移动端一般做的反爬策略比较少，可以从这里入手，寻找适合的站点。</p>

<p>理解自己要做什么，如何伪装成人类。仔细思考访问流程，针对性的有哪些反爬手段。把这些想通了，爬虫之路会好走很多。</p>

<p>转载请注明：<a href="http://lixindong.top">未命名的博客</a></p>

<h2 id="toc_4">相关文章和资料</h2>

<p>技术语言资料请自行google。</p>

<ol>
<li><a href="https://www.zhihu.com/question/28168585">如何应对网站反爬虫策略？如何高效地爬大量数据?</a></li>
<li><a href="https://www.zhihu.com/question/27621722">能利用爬虫技术做到哪些很酷很有趣很有用的事情?</a>(很有意思)</li>
<li><a href="http://cuiqingcai.com/1052.html">Python爬虫学习系列教程</a>(推荐)</li>
<li><a href="http://www.voidcn.com/blog/eastmount/article/p-5954929.html">[Python爬虫] Selenium爬取新浪微博移动端热点话题及评论 (下)</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Github的Webhooks进行网站的自动化部署]]></title>
    <link href="lixindong.top/14691078063823.html"/>
    <updated>2016-07-21T21:30:06+08:00</updated>
    <id>lixindong.top/14691078063823.html</id>
    <content type="html"><![CDATA[
<p>使用mWeb做自己的博客，服务器没有直接使用github的gh-pages功能，而是部署到了自己的服务器上。<br/>
从此更新博客变成了三步走：1. 使用mWeb生成静态网页 2. push 到github 3. 登录服务器拉取最新内容。</p>

<p>昨天想到，能不能再简化一些步骤，让我的文章push到github后，让服务器自动拉取文章，部署新内容。说干就干，实施想法。</p>

<h2 id="toc_0">1. 目标</h2>

<p>服务器自动拉取push到github上的新文章。</p>

<h2 id="toc_1">2. 想法</h2>

<p>想法一: 定时检查置顶repo的提交，有更新，则启动部署流程。（主动查询方式）<br/>
想法二: github是否支持事件提醒或者第三方有无支持。(被动唤醒方式)(相当于消息推送)</p>

<h2 id="toc_2">3. 思考</h2>

<p>主动查询，耗费cpu时间及流量，并且必然会和github产生同步间隔。<br/>
被动唤醒，不会消耗不必要的资源，若是支持必然是第一选项。</p>

<h2 id="toc_3">4. 查阅资料(可行性分析)</h2>

<p>github支持Webhooks及大量的第三方服务，可以很好得对repo的push等操作做出反应。</p>

<p><strong>Webhooks做了什么?</strong><br/>
当github收到repo的操作行为时，会向指定的url发送一个带有描述操作内容的post请求。</p>

<h2 id="toc_4">5. 实现思路(总结)</h2>

<p>对指定repo注册webhooks，指向我的服务器上的接口，服务器解析数据，若操作是push，则进行部署行为。</p>

<h2 id="toc_5">6. 实现</h2>

<h4 id="toc_6">6.1 部署脚本：</h4>

<p><strong>deploy.sh</strong></p>

<pre><code>#!/bin/bash

LOG_FILE=&quot;/var/log/blog_deploy.log&quot;

date &gt;&gt; &quot;$LOG_FILE&quot;
echo &quot;Start deployment&quot; &gt;&gt;&quot;$LOG_FILE&quot;
cd /Path/need/be/deployed/
echo &quot;pulling source code...&quot; &gt;&gt; &quot;$LOG_FILE&quot;
git checkout origin gh-pages
git pull origin gh-pages
echo &quot;Finished.&quot; &gt;&gt;&quot;$LOG_FILE&quot;
echo &gt;&gt; $LOG_FILE
</code></pre>

<p>每当接收到带push的post请求时，执行上面的脚本。</p>

<h4 id="toc_7">6.2 处理post请求</h4>

<p>注：以下nodejs内容摘自<a href="http://www.lovelucy.info/auto-deploy-website-by-webhooks-of-github-and-gitlab.html">曾曦前辈博客－尘埃落定</a></p>

<blockquote>
<p>然后我们就要写一个脚本在 <a href="http://dev.lovelucy.info/incoming">http://dev.lovelucy.info/incoming</a> 这里接受 POST 请求了。因为本人机器上跑的是 node，俺就找了个 nodejs 的中间件 github-webhook-handler 。如果你要部署的是 PHP 网站，那你应该找一个世界上最好的语言 PHP 的版本，或者自己写一个，只需要接收 $_POST 嘛，好简单的，不多废话啦。么么哒 ( • ̀ω•́ )</p>
</blockquote>

<pre><code>$ npm install -g github-webhook-handler
</code></pre>

<blockquote>
<p>鉴于在天朝的服务器上 npm 拉 repo 比拉屎还难的状况，我们可以 选用 阿里的镜像，据说 10 分钟和官方同步一次。_(:3 」∠ )_</p>
</blockquote>

<pre><code>$ npm install -g cnpm --registry=http://r.cnpmjs.org
$ cnpm install -g github-webhook-handler
</code></pre>

<blockquote>
<p>好了，万事俱备，下面是 NodeJS 的监听程序 deploy.js</p>
</blockquote>

<pre><code>var http = require(&#39;http&#39;)
var createHandler = require(&#39;github-webhook-handler&#39;)
var handler = createHandler({ path: &#39;/incoming&#39;, secret: &#39;myHashSecret&#39; }) 
// 上面的 secret 保持和 GitHub 后台设置的一致
 
function run_cmd(cmd, args, callback) {
  var spawn = require(&#39;child_process&#39;).spawn;
  var child = spawn(cmd, args);
  var resp = &quot;&quot;;
 
  child.stdout.on(&#39;data&#39;, function(buffer) { resp += buffer.toString(); });
  child.stdout.on(&#39;end&#39;, function() { callback (resp) });
}
 
http.createServer(function (req, res) {
  handler(req, res, function (err) {
    res.statusCode = 404
    res.end(&#39;no such location&#39;)
  })
}).listen(7777)
 
handler.on(&#39;error&#39;, function (err) {
  console.error(&#39;Error:&#39;, err.message)
})
 
handler.on(&#39;push&#39;, function (event) {
  console.log(&#39;Received a push event for %s to %s&#39;,
    event.payload.repository.name,
    event.payload.ref);
  run_cmd(&#39;sh&#39;, [&#39;./deploy.sh&#39;], function(text){ console.log(text) });
})
 
/*
handler.on(&#39;issues&#39;, function (event) {
  console.log(&#39;Received an issue event for % action=%s: #%d %s&#39;,
    event.payload.repository.name,
    event.payload.action,
    event.payload.issue.number,
    event.payload.issue.title)
})
*/
</code></pre>

<p>之后把服务器跑起来就可以了。</p>

<pre><code>$ nodejs deploy.js
</code></pre>

<p>为了防止服务挂掉，我们有很多方式可以处理。我选择了用系统自带的nohup。</p>

<pre><code>$ nohup nodejs deply.js &amp;
</code></pre>

<p>曾曦前辈使用的是 NodeJs的forever，也可以使用python的supervisor。<br/>
<a href="http://www.lovelucy.info/auto-deploy-website-by-webhooks-of-github-and-gitlab.html">曾曦前辈博客－尘埃落定</a>有相关介绍。</p>

<h4 id="toc_8">6.3 配置Webhooks监听</h4>

<p>将Payload URL指向自己服务器的接口<br/>
<img src="media/14691078063823/14691103881759.jpg" alt=""/></p>

<pre><code>var handler = createHandler({ path: &#39;/incoming&#39;, secret: &#39;myHashSecret&#39; })

http.createServer(function (req, res) {
  handler(req, res, function (err) {
    res.statusCode = 404
    res.end(&#39;no such location&#39;)
  })
}).listen(7777)
</code></pre>

<p>这是deploy.js 的关键代码。<br/>
listen(7777)，表明服务器监听的是7777端口<br/>
path:&#39;/incoming&#39;，表示在 ip:7777/incoming 接收POST请求<br/>
secret: &#39;myHashSecret&#39;, 要求和上图的Secret字段一样，不然服务器会因为不匹配，拒绝接收到的请求。主要为了防止第三方向这个端口发送请求。</p>

<h2 id="toc_9">7. 最后梳理一下</h2>

<p><strong>6.3 那里知道什么时候有人提交文章了，然后告诉6.2 有人push</strong><br/>
<strong>6.2 从6.3 得到消息，看下你的密码(secret)和我的一样不，如果一样，我就把这个消息告诉6.1</strong><br/>
<strong>6.1 开始跑到github数据库拉取最新的数据，部署完成</strong></p>

<h2 id="toc_10">澄清</h2>

<p>有朋友告诉我，复制粘贴的部分比较多。即便加了转载说明，也不是很好。<br/>
在这里澄清一下：<br/>
网络上技术文章特点：<strong>多</strong>，<strong>杂</strong>，<strong>全</strong><br/>
可用的经典实例: <strong>少</strong><br/>
自生产实例的成本: <strong>费时</strong><br/>
一篇<strong>全原创</strong>的优质文章需要：<strong>思考</strong>＋<strong>原创实例</strong>＋<strong>码字</strong>＋<strong>重复前三项</strong> 。<br/>
而对于学习者而言，<strong>思想＋实例＋思路</strong>已经满足80%。<br/>
所以我认为，一篇能学到东西的技术文章，并不需要<strong>全原创</strong>。<br/>
清晰的思路＋前人提供的经典实例＋个人思考，传达到位即可。</p>

<p><strong>前人都总结好了，你再发一遍，不是制造网络垃圾吗？</strong><br/>
打造一个以思路清晰著称的博客，专注于技术文章整理、重成文是本博客存在的意义。我不是垃圾的生产者，我是大自然的清道夫。</p>

<p>欢迎关注个人微博<a href="http://weibo.com/2293237681">斯科特</a>，进行技术、非技术交流。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[10分钟快速搭建无限制流量的"VPN"（shadowsocks协议）]]></title>
    <link href="lixindong.top/14686843615662.html"/>
    <updated>2016-07-16T23:52:41+08:00</updated>
    <id>lixindong.top/14686843615662.html</id>
    <content type="html"><![CDATA[
<p>Too Long No Read： 阅读标题和标重点部分就能了解全部内容。</p>

<h2 id="toc_0">1. 简介</h2>

<p>良心声明: 有朋友说10分钟根本连文章都看不完，哪能建起个自己完全不熟悉的V P N 呢？<br/>
所以在这里必须解释一波：10分钟指的是开始动手到可以使用的时间。并不包括读这篇文章的时间，也不包括你在搭建服务过程中自我纠结的时间（比如，租多大的服务器？用什么密码？剁完手后又要饿多久的肚子才能给女票买下件内衣？之类。别问我为什么知道你一定是男的）最后，不包括运行出错，调试测试的时间。因为，按我说的做，你根本不可能失败！</p>

<p>接下来是简介：<br/>
说是无限制流量，其实骗你的啦（可爱）。说是VPN，其实不限于VPN。（本文搭建的也不是VPN，而是被称为Shadowsocks的协议。）<br/>
接下来解释：<br/>
<strong>原理:</strong> 租一个国外的服务器 --&gt;这个服务器上搭建自己的VPN --&gt; 通过这个VPN科学上网。<br/>
<strong>无限制流量：</strong>500G，1T，甚至更多。一月这么多，用的完吗？用不完不就相当于无限制。<br/>
<strong>VPN：</strong>既然有了自己墙外的服务器，就可以用它搭建任何自己想要的科学上网利器。本文章主要介绍当下最安全、最流行的<strong>ShadowSocks</strong>.<br/>
<strong>价格：</strong>很便宜！！很便宜！！很便宜！！</p>

<h2 id="toc_1">2. 工具篇</h2>

<h3 id="toc_2">2.1 VPS 国外的服务器</h3>

<p><strong>VPS：</strong>Virtual Private Server 虚拟专用服务器<br/>
其实你就知道是个自己能用来搭建科学上网服务的主机就行了。<br/>
一般不了解的人，第一反应都是：卧槽，我指用个10G流量只能翻墙的VPN就几十块一个月。那租一个可以干很多事情、不限流量的服务器，岂不要几百几千？其实不用998、不用98，绝对用你想不到的价格，买到最不可思议的产品！<br/>
<strong>推荐：</strong></p>

<h4 id="toc_3">1. 搬瓦工 (便宜推荐)</h4>

<p><strong>优点：</strong>便宜！！最低500G流量，年购19.99美刀，使用优惠码还可以再减1刀左右。相当于每月10元。这价格已经比大多数VPN便宜了。<br/>
<strong>支持支付宝交易！</strong><br/>
<strong>支持30天内退款</strong> 一般一个工作日内就能回复，支付宝收到2～3天。<br/>
<strong>一键配置shadowsocks！</strong>如果使用搬瓦工，那后面的内容都不用看了，点下面的链接注册即可。<br/>
官方网址：<a href="https://bandwagonhost.com/">https://bandwagonhost.com/</a></p>

<p>数据中心：美国西雅图、佛罗里达、洛杉矶、荷兰 套餐价格：64MB内存年3.99美元 / 96MB内存年4.99美元/128MB内存年5.99美元/512MB内存年9.99美元 简单介绍：IT7官方旗下的低价VPS主机产品，拥有速度较好的西岸亚利桑那州机房，最低年付仅需3.99美元，我们可以用来学习、工作项目演示，以及需要支持PPP/TUN搭建工具使用需求。拥有4个数据中心，而且可以自由切换IP，更换不同的IP，解决IP被封问题。<br/>
    •   CPU：1核心CPU<br/>
    •   内存：256MB<br/>
    •   硬盘：10GB SSD<br/>
    •   流量：500GB<br/>
    •   端口：1Gbps<br/>
    •   架构：OpenVZ+KiwiVM面板<br/>
    •   IP数：1独立IP<br/>
    •   系统：Linux<br/>
    •   价格：<strong>$19.99/年</strong>（购买）</p>

<pre><code>•   CPU：1核心CPU
•   内存：4096MB
•   硬盘：30GB SSD
•   流量：2000GB
•   端口：1Gbps
•   架构：OpenVZ+KiwiVM面板
•   IP数：1独立IP
•   系统：Linux
•   价格：$6.99/月（购买）

•   CPU：1核心CPU
•   内存：512MB
•   硬盘：10GB SSD
•   流量：1000GB
•   端口：1Gbps
•   架构：OpenVZ+KiwiVM面板
•   IP数：1独立IP
•   系统：Linux
•   价格：$19.99/年（弗里蒙特）

•   CPU：1核心CPU
•   内存：1024MB
•   硬盘：20GB SSD
•   流量：2000GB
•   端口：1Gbps
•   架构：OpenVZ+KiwiVM面板
•   IP数：1独立IP
•   系统：Linux
•   价格：$49.99/年（弗里蒙特）

•   CPU：2核心CPU
•   内存：512MB
•   硬盘：20GB SSD
•   流量：1000GB
•   端口：1Gbps
•   架构：OpenVZ+KiwiVM面板
•   IP数：1独立IP
•   系统：Linux
•   价格：$4.99/月（购买）

•   CPU：3核心CPU
•   内存：1024MB
•   硬盘：40GB SSD
•   流量：2000GB
•   端口：1Gbps
•   架构：OpenVZ+KiwiVM面板
•   IP数：1独立IP
•   系统：Linux
•   价格：$9.99/月（购买）
</code></pre>

<h4 id="toc_4">2. Vultr （稳定推荐，我自己目前在用）</h4>

<p><a href="http://www.vultr.com/?ref=6920216">注册网址</a><br/>
<strong>优点</strong> <br/>
1. 注册赠送20美金。使用最低标准服务5刀/月，相当于可以免费使用4个月。<br/>
2. 服务稳定。至少我还没碰到过当机情况。<br/>
3. 第三点是缺点，想获得20美金，必须使用信用卡支付，并且扣除2.5美元的验证费。（以后会返还）<br/>
<a href="http://www.vultr.com/?ref=6921913-3B">点击注册并获取20美金</a></p>

<p>数据中心：日本、洛杉矶、英国、法国、德国、荷兰、澳大利亚等14个机房<br/>
套餐价格：KVM 768MB 15GB SSD 1TB月流量 <strong>$5/月</strong><br/>
简单介绍：Vultr作为全球最大的游戏主机提供商背景之一，上线之后以高质的性价比、12个数据中心，以及新注册账户赠送5美金的账户使用金优惠促销，吸引广大的用户。作为我们用户，日本、洛杉矶等数据中心速度较好，如果有需要海外其他机房也可以在其12个数据中心中选择到适合自己的。</p>

<p>官方网站：<a href="https://www.vultr.com">https://www.vultr.com</a></p>

<h4 id="toc_5">3. 其它</h4>

<p>因为我指用过上面两个，所以其他的也不多介绍了。列个列表，大家可以自行google。<br/>
Linode: 很多人推荐。速度快。价格中等。<br/>
DigitalOcean: 很多人推荐。速度快，价格差不多。</p>

<h4 id="toc_6">为什么说价格便宜</h4>

<p>除了明码标价的价格。其实本身已经和普通VPN价格差不多了。但是仍然，有一点。虽然流量并不是无限，但是带宽并没有限制。就是说，在流量还够用的前提下，和朋友一起使用，是几乎不影响访问速度的，价格又能再除以...,最后折算下来非常可观。当然，不能超越物理极限，3、5个人一起用，是保险又便利的方式。</p>

<h4 id="toc_7">价格上，贵就是好</h4>

<p>对于同类物品，贵就是好。所以无论是我提到的，还是没提到的，虽然价格有差异，但是毕竟体现在服务好坏上。所以，如果你发现不同价格，买到了同样的配置，但是实际效果却有差距，这很正常。</p>

<h3 id="toc_8">2.2 Python Shadowsocks 搭建服务的工具和协议</h3>

<p>Shadowsocks 属于socks5 代理，稳定性好，抗干扰能力强。</p>

<h4 id="toc_9">搭建服务 三步走</h4>

<p>1 . 安装<br/>
 在CentOS中运行下面两条命令就完成了shadowsocks的安装了：</p>

<pre><code>yum install python-setuptools &amp;&amp; easy_install pip
pip install shadowsocks
</code></pre>

<p>2 . 配置<br/>
完成之后创建一个配置文件 /etc/shadowsocks.json，写入以下内容：</p>

<pre><code>{ 
        &quot;server&quot;:&quot;0.0.0.0&quot;,            #服务器IP地址
        &quot;server_port&quot;:8388,                 #服务监听端口
        &quot;local_port&quot;:1080,                  #本地连接端口
        &quot;password&quot;:&quot;barfoo&quot;,               #加密传输使用到的密码
        &quot;timeout&quot;:600,                      #连接超时时间
        &quot;method&quot;:&quot;aes-256-cfb&quot;,             #加密算法
}
</code></pre>

<p>3 . 启动、停止<br/>
运行下面的命令来启动和停止后台服务：</p>

<pre><code class="language-ssserver">ssserver -c /etc/shadowsocks.json -d stop
</code></pre>

<h4 id="toc_10">然后你就可以使用上面的配置连接shadowsocks了。</h4>

<ol>
<li>客户端如何用？</li>
</ol>

<p>各个平台使用的客户端都有差异，但是用到的信息就这些：<br/>
－ 服务器IP: 不是上面的0.0.0.0，是你申请的VPS，会提供一个ip。打开网站，登录，找到它<br/>
－ 端口(port): 8388<br/>
－ 协议类型: aes-256-cfb 一般默认就这个，不用换。但还是要看一眼。<br/>
－ 密码(password): barfoo<br/>
连接，欢呼。</p>

<h2 id="toc_11">3. 拓展</h2>

<p>可以点赞了。</p>

<p>欢迎关注微博进行技术交流 <a href="http://weibo.com/2293237681">斯科特</a><br/>
**</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PokemonGo破解]]></title>
    <link href="lixindong.top/14685051740290.html"/>
    <updated>2016-07-14T22:06:14+08:00</updated>
    <id>lixindong.top/14685051740290.html</id>
    <content type="html"><![CDATA[
<ol>
<li>简单的更改unity位置
报错
<code>07-14 22:04:02.801 7512-9260/? E/NianticAccountManager: User cannot be authenticated.
                                                    com.google.android.gms.auth.GoogleAuthException: INVALID_AUDIENCE
                                                        at com.google.android.gms.auth.GoogleAuthUtil.zza(Unknown Source)
                                                        at com.google.android.gms.auth.GoogleAuthUtil.getToken(Unknown Source)
                                                        at com.google.android.gms.auth.GoogleAuthUtil.getToken(Unknown Source)
                                                        at com.google.android.gms.auth.GoogleAuthUtil.getToken(Unknown Source)
                                                        at com.nianticlabs.nia.account.NianticAccountManager.getAccount(NianticAccountManager.java:75)</code></li>
</ol>

<h2 id="toc_0">测试一下是否有签名登录保护之类的策略。</h2>

<p>使用apk反编译后直接重新打包，打开app。<br/>
google账号鉴权成功。没问题！</p>

<h2 id="toc_1">测试做些简单的修改</h2>

<p><code>    invoke-virtual {p0, v0}, Lcom/kodelabs/boilerplate/presentation/ui/activities/MainActivity;-&gt;updateLocation(Landroid/location/Location;)V</code><br/>
<code><br/>
.method public updateLocation(Landroid/location/Location;)V<br/>
    .locals 2<br/>
    .param p1, &quot;location&quot;    # Landroid/location/Location;</p>

<pre><code>.prologue
.line 31
const-wide v0, -0x3fa7170e2c12ad82L    # -99.63976

invoke-virtual {p1, v0, v1}, Landroid/location/Location;-&gt;setLongitude(D)V

.line 32
const-wide v0, 0x4043d0087ca643ccL    # 39.625259

invoke-virtual {p1, v0, v1}, Landroid/location/Location;-&gt;setLatitude(D)V

.line 33
return-void
</code></pre>

<p>.end method</code></p>

<h2 id="toc_2">打包安装</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Creating a Navigation Drawer]]></title>
    <link href="lixindong.top/14583860309318.html"/>
    <updated>2016-03-19T19:13:50+08:00</updated>
    <id>lixindong.top/14583860309318.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">表现</h2>

<p>Navigation Drawer <br/>
<img src="media/14583860309318/14583864312339.jpg" alt=""/></p>

<p>手指从屏幕左边右滑，打开的这个像 Menu 一样的的页面就被称为 NavigationDrawer。<br/>
谷歌在 MD 规范中详细说明了它的设计规范，在开始设计你的应用时请务必阅读作为参考。<br/>
<a href="http://developer.android.com/design/patterns/navigation-drawer.html">Navigation Drawer</a></p>

<h2 id="toc_1">实现思路</h2>

<p>分析一下，很容易看出来，基本是分为两层。上层的这个 Drawer 层(包含你看到的这个 View 和可能被忽略的覆盖下层的阴影)，下层的包含了页面本身的内容层(ActionBar TabLayout 其它内容)。</p>

<h2 id="toc_2">使用方式</h2>

<p>所以，使用也很符合思考模式：以 DrawerLayout 为根 View 包含两层子 View。</p>

<h3 id="toc_3">1. XML 文件</h3>

<pre><code class="language-&lt;android.support.v4.widget.DrawerLayout">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:id=&quot;@+id/drawer_layout&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;
    &lt;!-- The main content view --&gt;
    &lt;FrameLayout
        android:id=&quot;@+id/content_frame&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot; /&gt;
    &lt;!-- The navigation drawer --&gt;
    &lt;ListView android:id=&quot;@+id/left_drawer&quot;
        android:layout_width=&quot;240dp&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_gravity=&quot;start&quot;
        android:choiceMode=&quot;singleChoice&quot;
        android:divider=&quot;@android:color/transparent&quot;
        android:dividerHeight=&quot;0dp&quot;
        android:background=&quot;#111&quot;/&gt;
&lt;/android.support.v4.widget.DrawerLayout&gt;
</code></pre>

<p><strong>注意的点</strong><br/>
*  内容层必须是DrawerLayout 的第一个子 View。因为 XML 以 View 的顺序决定 Z 的次序。<br/>
*  drawer 层必须设定 android:layout_gravity 属性。用来支持 right-to-left 语言。注意用 &quot;start&quot; 代替 &quot;left&quot;。<br/>
*  drawer 层的宽度小于320dp，这样展开时也能看到下方的内容。高度 match_parent。</p>

<h3 id="toc_4">2. 代码对内容进行配置</h3>

<pre><code>public class MainActivity extends Activity {
    private String[] mPlanetTitles;
    private DrawerLayout mDrawerLayout;
    private ListView mDrawerList;
    ...

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        mPlanetTitles = getResources().getStringArray(R.array.planets_array);
        mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout);
        mDrawerList = (ListView) findViewById(R.id.left_drawer);

        // Set the adapter for the list view
        mDrawerList.setAdapter(new ArrayAdapter&lt;String&gt;(this,
                R.layout.drawer_list_item, mPlanetTitles));
        // Set the list&#39;s click listener
        mDrawerList.setOnItemClickListener(new DrawerItemClickListener());

        ...
    }
}
</code></pre>

<h3 id="toc_5">3. 处理其它问题</h3>

<h4 id="toc_6">3.1 处理点击事件导航</h4>

<p>给 Drawer 的 ListView 设置 OnItemClickListener 就行。<br/>
<strong>示例代码</strong><br/>
```<br/>
private class DrawerItemClickListener implements ListView.OnItemClickListener {<br/>
    @Override<br/>
    public void onItemClick(AdapterView parent, View view, int position, long id) {<br/>
        selectItem(position);<br/>
    }<br/>
}</p>

<p>/** Swaps fragments in the main content view */<br/>
private void selectItem(int position) {<br/>
    // Create a new fragment and specify the planet to show based on position<br/>
    Fragment fragment = new PlanetFragment();<br/>
    Bundle args = new Bundle();<br/>
    args.putInt(PlanetFragment.ARG_PLANET_NUMBER, position);<br/>
    fragment.setArguments(args);</p>

<pre><code>// Insert the fragment by replacing any existing fragment
FragmentManager fragmentManager = getFragmentManager();
fragmentManager.beginTransaction()
               .replace(R.id.content_frame, fragment)
               .commit();

// Highlight the selected item, update the title, and close the drawer
mDrawerList.setItemChecked(position, true);
setTitle(mPlanetTitles[position]);
mDrawerLayout.closeDrawer(mDrawerList);
</code></pre>

<p>}</p>

<p>@Override<br/>
public void setTitle(CharSequence title) {<br/>
    mTitle = title;<br/>
    getActionBar().setTitle(mTitle);<br/>
}<br/>
```</p>

<h4 id="toc_7">监听 Drawer 展开、关闭事件</h4>

<p>调用 DrawerLayout.setDrawerListener() 方法，传递一个 DrawerLayout.DrawerListener 接口的实现。<br/>
实现这个接口有两种方式。<br/>
1. 直接实现 DrawerListener.<br/>
2. 写一个继承 ActionBarDrawerToggle 的子类，这个类实现了这个接口，你可以在子类中重写 DrawerListener 接口函数。</p>

<p><strong>示例代码</strong><br/>
```<br/>
public class MainActivity extends Activity {<br/>
    private DrawerLayout mDrawerLayout;<br/>
    private ActionBarDrawerToggle mDrawerToggle;<br/>
    private CharSequence mDrawerTitle;<br/>
    private CharSequence mTitle;<br/>
    ...</p>

<pre><code>@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    ...

    mTitle = mDrawerTitle = getTitle();
    mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout);
    mDrawerToggle = new ActionBarDrawerToggle(this, mDrawerLayout,
            R.drawable.ic_drawer, R.string.drawer_open, R.string.drawer_close) {

        /** Called when a drawer has settled in a completely closed state. */
        public void onDrawerClosed(View view) {
            super.onDrawerClosed(view);
            getActionBar().setTitle(mTitle);
            invalidateOptionsMenu(); // creates call to onPrepareOptionsMenu()
        }

        /** Called when a drawer has settled in a completely open state. */
        public void onDrawerOpened(View drawerView) {
            super.onDrawerOpened(drawerView);
            getActionBar().setTitle(mDrawerTitle);
            invalidateOptionsMenu(); // creates call to onPrepareOptionsMenu()
        }
    };

    // Set the drawer toggle as the DrawerListener
    mDrawerLayout.setDrawerListener(mDrawerToggle);
}

/* Called whenever we call invalidateOptionsMenu() */
@Override
public boolean onPrepareOptionsMenu(Menu menu) {
    // If the nav drawer is open, hide action items related to the content view
    boolean drawerOpen = mDrawerLayout.isDrawerOpen(mDrawerList);
    menu.findItem(R.id.action_websearch).setVisible(!drawerOpen);
    return super.onPrepareOptionsMenu(menu);
}
</code></pre>

<p>}<br/>
```</p>

<h4 id="toc_8">通过 App Icon 打开、关闭 Drawer</h4>

<p>通过使用 ActionBarDrawerToggle 类，可以控制这些行为。<br/>
* 点击控制 Drawer 行为<br/>
* 指定展开时的 icon</p>

<p>标准的导航 Icon 图标在 (Download the Action Bar Icon Pack)[<a href="http://developer.android.com/downloads/design/Android_Design_Icons_20130926.zip">http://developer.android.com/downloads/design/Android_Design_Icons_20130926.zip</a>]</p>

<p>最后你需要在 Activity 的生命周期中使用 ActionBarDrawerToggle 的这些方法。<br/>
<strong>示例代码</strong><br/>
```<br/>
public class MainActivity extends Activity {<br/>
    private DrawerLayout mDrawerLayout;<br/>
    private ActionBarDrawerToggle mDrawerToggle;<br/>
    ...</p>

<pre><code>public void onCreate(Bundle savedInstanceState) {
    ...

    mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout);
    mDrawerToggle = new ActionBarDrawerToggle(
            this,                  /* host Activity */
            mDrawerLayout,         /* DrawerLayout object */
            R.drawable.ic_drawer,  /* nav drawer icon to replace &#39;Up&#39; caret */
            R.string.drawer_open,  /* &quot;open drawer&quot; description */
            R.string.drawer_close  /* &quot;close drawer&quot; description */
            ) {

        /** Called when a drawer has settled in a completely closed state. */
        public void onDrawerClosed(View view) {
            super.onDrawerClosed(view);
            getActionBar().setTitle(mTitle);
        }

        /** Called when a drawer has settled in a completely open state. */
        public void onDrawerOpened(View drawerView) {
            super.onDrawerOpened(drawerView);
            getActionBar().setTitle(mDrawerTitle);
        }
    };

    // Set the drawer toggle as the DrawerListener
    mDrawerLayout.setDrawerListener(mDrawerToggle);

    getActionBar().setDisplayHomeAsUpEnabled(true);
    getActionBar().setHomeButtonEnabled(true);
}

@Override
protected void onPostCreate(Bundle savedInstanceState) {
    super.onPostCreate(savedInstanceState);
    // Sync the toggle state after onRestoreInstanceState has occurred.
    mDrawerToggle.syncState();
}

@Override
public void onConfigurationChanged(Configuration newConfig) {
    super.onConfigurationChanged(newConfig);
    mDrawerToggle.onConfigurationChanged(newConfig);
}

@Override
public boolean onOptionsItemSelected(MenuItem item) {
    // Pass the event to ActionBarDrawerToggle, if it returns
    // true, then it has handled the app icon touch event
    if (mDrawerToggle.onOptionsItemSelected(item)) {
      return true;
    }
    // Handle your other action bar items...

    return super.onOptionsItemSelected(item);
}
...
</code></pre>

<p>}<br/>
```</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Smartoo 开发中遇到的问题和解决]]></title>
    <link href="lixindong.top/14539061256073.html"/>
    <updated>2016-01-27T22:48:45+08:00</updated>
    <id>lixindong.top/14539061256073.html</id>
    <content type="html"><![CDATA[
<p><code>Weibo客户端sso认证不成功</code><br/>
uri mismatch 的问题是因为weibo开放平台配置有延迟，在平台上修改redirect uri后，隔天就可以通过了<br/>
闪退的问题，可能是由于不是打的release的包，做reader的分享时就有这样的问题。明天用release的包测试一下。<br/>
使用web验证可以顺利通过。</p>

<p><code>未通过审核帐号的接口调用限制</code><br/>
大概在200-300次之间</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[风の诗(风之诗 Wind Song)]]></title>
    <link href="lixindong.top/14530335489771.html"/>
    <updated>2016-01-17T20:25:48+08:00</updated>
    <id>lixindong.top/14530335489771.html</id>
    <content type="html"><![CDATA[
<p>F4 </p>

<h2 id="toc_0">音程</h2>

<p>n度  大n度  小n度<br/>
和弦  和谐，不和谐<br/>
和弦 根音＋1 3 5度，小三度＋大三度  minor和弦， 大三度＋小三度 大和弦， 小三度＋小三度 减和弦</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[下町火箭]]></title>
    <link href="lixindong.top/14488126785387.html"/>
    <updated>2015-11-29T23:57:58+08:00</updated>
    <id>lixindong.top/14488126785387.html</id>
    <content type="html"><![CDATA[
<p><img src="http://i12.tietuku.com/82e26086176beb7c.png" alt="http://i12.tietuku.com/82e26086176beb7c.png"/><br/>
《下町火箭》讲述的是小小的佃制造所通过努力，成功帮助帝国重工将火箭升空的一系列感人的故事。<br/>
通常这类故事都会被打上励志的标签，本剧却不止于此。</p>

<p>如何能够在一次火箭发射失败后从头再来，潜心研究。如何平衡工作和女儿的关系。如何能像信任自己的孩子一般信任自己的作品。<br/>
《下町火箭》更多讲的是人看待梦想的态度，人与人之间的羁绊。</p>

<p>日剧总是把人们的这些感情解读并重点展现出来，这也是为什么我会对日剧如此钟爱。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[app 我有一个问题]]></title>
    <link href="lixindong.top/14464734385012.html"/>
    <updated>2015-11-02T22:10:38+08:00</updated>
    <id>lixindong.top/14464734385012.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>这个app不是问答式的社区</p>
</blockquote>

<h2 id="toc_0">疑问</h2>

<p>人每天都会产生疑问，但每天也有疑问被搁置下来，没有解答<br/>
想想，如果这些问题全部或者大部分都能被解决并记录。那么一年以后的自己将会变得多么博学</p>

<h2 id="toc_1">想想，这些问题被搁置的原因</h2>

<ul>
<li><strong>时间</strong>:   “我在做其它事情，分不开时间”</li>
<li><strong>优先级</strong>:  “其实问题也不是那么重要”</li>
<li><strong>复杂性</strong>:  “这可能不是一会儿能了解的”</li>
<li><strong>领域</strong>:   “无从下手”</li>
<li><strong>人真是复杂慵懒的动物</strong>:   “想之后解决，然后就忘记了，或者想起来也没兴趣了”</li>
<li><strong>比干货更简洁</strong>:   “我只想知道个大概，可网上的答案总不能让我满意。要么太全面，要么没讲到点”</li>
</ul>

<blockquote>
<p>没能在产生疑问的<strong>时间</strong>，找到合适的<strong>资料</strong>,和那个能一句话讲到点的<strong>人</strong>。</p>
</blockquote>

<h2 id="toc_2">因此，我们需要什么</h2>

<p>正式点讲 <strong>最简洁，最get到point的回答</strong><br/>
不正式点 <strong>最右神回复</strong></p>

<blockquote>
<p>然而提供内容并不是我们要做的</p>

<p>人从心底总是自私的<br/>
即便在<em>知乎</em>这类为他人服务的平台上，人们也总是倾向于回答自己感兴趣的提问</p>
</blockquote>

<h2 id="toc_3">如何做</h2>

<p>因此，<br/>
我们只是提供给用户一个私人的<strong>记录平台</strong>, 个人的问题<strong>管理平台</strong></p>

<h4 id="toc_4">定位：</h4>

<ul>
<li>个人手账类的记事本</li>
<li>将公开内容聚合的知识库</li>
<li>社区</li>
</ul>

<h4 id="toc_5">功能</h4>

<ul>
<li>随时定义新概念：有时为了讲解方便，需要用一个词代替一个概念。在当下没有相应的概念时，一个新的概念词诞生是被允许和值得推荐的。我们也有机制推荐其中优秀和广为传播的新概念。</li>
<li>随时记录新疑问</li>
<li>对于未填补答案的问题

<ul>
<li>自动归档到todo</li>
<li>手动填补答案</li>
<li>查看知识库中推荐的已有答案</li>
<li>公开征求答案</li>
<li>选择合适的答案mark到自己的手账中</li>
</ul></li>
<li>对于已填补的问题

<ul>
<li>根据艾宾浩斯记忆法，进行复习</li>
<li>知识库中有相关问题的优解，推荐</li>
<li>在知识库中作为备选答案，接受其它用户浏览、评分</li>
</ul></li>
<li>知识库的答案全部由运营商或其它用户提供</li>
<li>打赏功能：对于很好地解决了自己问题的<strong>优质</strong>答案，用户可选择进行打赏</li>
<li>专题功能：专家级的用户可以创建自己的专题，专题内容通过一定的标准（质与量），可以将其电子版内容打包出售</li>
<li>发烧圈子：可由专题、小组组成。是人的圈子，也是内容的圈子。一个内容可以在某个圈子发表，圈子内可见。一个用户可以在圈子中被推荐。</li>
<li>热门的分类社区：howto类，购物类，等</li>
</ul>

<h4 id="toc_6">用户群体</h4>

<ul>
<li>文青</li>
<li>动手达人</li>
<li>领域专家</li>
<li>爱思考的人</li>
<li>拖延症患者</li>
<li>除上面以外的其他人</li>
</ul>

<h4 id="toc_7">盈利模式</h4>

<p>这是我的一个问题。期待社区帮我解答。</p>

<h2 id="toc_8">最后</h2>

<p><strong>我们希望并渴求精炼的一句话答案</strong> <br/>
帮助大多数人瞬间开窍</p>

<p><strong>我们也渴望专业级别的教科书</strong><br/>
提升你自己的同时，带给世界更优质的内容</p>

]]></content>
  </entry>
  
</feed>
