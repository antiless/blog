<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[博客未命名]]></title>
  <link href="lixindong.top/atom.xml" rel="self"/>
  <link href="lixindong.top/"/>
  <updated>2016-07-30T00:20:21+08:00</updated>
  <id>lixindong.top/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[谈谈爬虫-模拟登录思路]]></title>
    <link href="lixindong.top/14698088043297.html"/>
    <updated>2016-07-30T00:13:24+08:00</updated>
    <id>lixindong.top/14698088043297.html</id>
    <content type="html"><![CDATA[
<p>最近在做的sideproject，需要网络上的文章数据。于是顺便学习了下爬虫技术，也算是有些心得体会。写下来分享给刚入坑的新人。</p>

<h2 id="toc_0">怎么理解模拟登录？</h2>

<p>怎么理解模拟登录？<br/>
把这句话补全就是： 怎么(让机器)模拟(人在浏览器上的行为)登录(指定的网站)。<br/>
那么这个问题实际上问的是： 人通过浏览器登录网站时，浏览器为我们做了哪些事情。<br/>
那么我们需要做的只有：写一个脚本，让这个脚本模拟浏览器的行为，做我们希望它做的事情。</p>

<p>有兴趣参考:<br/>
 <a href="https://www.zhihu.com/question/34873227">当在浏览器地址栏输入一个URL后回车，将会发生的事情？</a></p>

<p><strong>那么</strong>，<br/>
人类在登录时做了哪些事情呢，很简单：<br/>
1. 打开登录页面<br/>
2. 输入用户名密码，有时可能还有验证码，各种各样的验证码<br/>
3. 点击登录<br/>
4. 等待浏览器自动跳转</p>

<p>只要你稍微懂一点html语言，就应该能分析个八九不离十。<br/>
机器人怎么做呢：<br/>
两种方式：</p>

<p><strong>方式一</strong>：<br/>
需要使用虚拟的浏览器引擎。<br/>
优点: 适合几乎所有的网站登录，可以人为输入验证码<br/>
缺点: 速度较慢<br/>
1. 请求登录页面的url，比如微博的(<a href="https://passport.weibo.cn/signin/login">https://passport.weibo.cn/signin/login</a>)<br/>
2. 分析html中的表单数据<br/>
2.1 找到输入用户名、密码的输入框<br/>
2.2 把输入框的text域替换成自己的用户名密码<br/>
3. 模拟点击提交按钮</p>

<p><strong>方式二</strong>：<br/>
分析登录信息提交方式，一般就是表单<br/>
优点: 轻量，速度快<br/>
缺点: 局限性大，对技术要求高，对验证码机制需要做针对的破解<br/>
1. 使用浏览器的调试模式查看网页<br/>
2. 检查是否使用表单提交<br/>
3. 点击登录按钮，查看发送的请求数据。主要查看参数有无加密验证或其它隐藏信息。<br/>
4. 使用分析结果进行请求操作</p>

<p>对于一般用户，所有的非特殊性需求都可以使用方式一进行完成。<br/>
若非是为了学习，推荐方式一。</p>

<p>技术资料请参考:<br/>
<a href="http://cuiqingcai.com/1052.html">Python爬虫学习系列教程</a>(推荐)<br/>
<a href="http://www.voidcn.com/blog/eastmount/article/p-5954929.html">[Python爬虫] Selenium爬取新浪微博移动端热点话题及评论 (下)</a></p>

<h2 id="toc_1">如何让脚本的行为看起来像人？</h2>

<p><strong>为什么要像人</strong><br/>
因为很多服务器会使用一些反爬技术拒绝爬虫软件访问。</p>

<p><strong>哪些东西让你看起来像人，哪些不像人</strong><br/>
像人，其实可以分为两点。<br/>
一类是看请求数据，是否符合是浏览器发出的正常数据，比如header内容。<br/>
一类是看行为模式，发送请求对象的行为更像人类还是机器人，比如请求的频率。</p>

<p>不像人，和上面对应。<br/>
从请求数据上看，你没说明user-agent,我就可以认为你是非法侵入。你没有带着我之前给你的饼干(cookie)来，我也可以拒绝你。<br/>
从行为模式上，同一个ip访问的频率过高，短时间内流量异常，都可以作为非人类处理。</p>

<h2 id="toc_2">结合反爬技术</h2>

<ol>
<li>需要登录用cookie</li>
<li>ip限制加代理</li>
<li>用user-agent告诉对方你是浏览器</li>
<li>服务器限制访问频率，加延迟</li>
<li>ajax异步加载，使用js引擎或者人工分析</li>
<li>redirect，最简单的方式虚拟内核＋延迟</li>
<li>验证码，虚拟内核</li>
</ol>

<h2 id="toc_3">如何找切入点？</h2>

<p>什么是好的登录页面？<br/>
没有验证码，非ajax异步加载。<br/>
不一定局限于pc端网页，app端、移动端一般做的反爬策略比较少，可以从这里入手，寻找适合的站点。</p>

<p>理解自己要做什么，如何伪装成人类。仔细思考访问流程，针对性的有哪些反爬手段。把这些想通了，爬虫之路会好走很多。</p>

<p>转载请注明：<a href="http://lixindong.top">未命名的博客</a></p>

<h2 id="toc_4">相关文章和资料</h2>

<p>技术语言资料请自行google。</p>

<ol>
<li><a href="https://www.zhihu.com/question/28168585">如何应对网站反爬虫策略？如何高效地爬大量数据?</a></li>
<li><a href="https://www.zhihu.com/question/27621722">能利用爬虫技术做到哪些很酷很有趣很有用的事情?</a>(很有意思)</li>
<li><a href="http://cuiqingcai.com/1052.html">Python爬虫学习系列教程</a>(推荐)</li>
<li><a href="http://www.voidcn.com/blog/eastmount/article/p-5954929.html">[Python爬虫] Selenium爬取新浪微博移动端热点话题及评论 (下)</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Github的Webhooks进行网站的自动化部署]]></title>
    <link href="lixindong.top/14691078063823.html"/>
    <updated>2016-07-21T21:30:06+08:00</updated>
    <id>lixindong.top/14691078063823.html</id>
    <content type="html"><![CDATA[
<p>使用mWeb做自己的博客，服务器没有直接使用github的gh-pages功能，而是部署到了自己的服务器上。<br/>
从此更新博客变成了三步走：1. 使用mWeb生成静态网页 2. push 到github 3. 登录服务器拉取最新内容。</p>

<p>昨天想到，能不能再简化一些步骤，让我的文章push到github后，让服务器自动拉取文章，部署新内容。说干就干，实施想法。</p>

<h2 id="toc_0">1. 目标</h2>

<p>服务器自动拉取push到github上的新文章。</p>

<h2 id="toc_1">2. 想法</h2>

<p>想法一: 定时检查置顶repo的提交，有更新，则启动部署流程。（主动查询方式）<br/>
想法二: github是否支持事件提醒或者第三方有无支持。(被动唤醒方式)(相当于消息推送)</p>

<h2 id="toc_2">3. 思考</h2>

<p>主动查询，耗费cpu时间及流量，并且必然会和github产生同步间隔。<br/>
被动唤醒，不会消耗不必要的资源，若是支持必然是第一选项。</p>

<h2 id="toc_3">4. 查阅资料(可行性分析)</h2>

<p>github支持Webhooks及大量的第三方服务，可以很好得对repo的push等操作做出反应。</p>

<p><strong>Webhooks做了什么?</strong><br/>
当github收到repo的操作行为时，会向指定的url发送一个带有描述操作内容的post请求。</p>

<h2 id="toc_4">5. 实现思路(总结)</h2>

<p>对指定repo注册webhooks，指向我的服务器上的接口，服务器解析数据，若操作是push，则进行部署行为。</p>

<h2 id="toc_5">6. 实现</h2>

<h4 id="toc_6">6.1 部署脚本：</h4>

<p><strong>deploy.sh</strong></p>

<pre><code>#!/bin/bash

LOG_FILE=&quot;/var/log/blog_deploy.log&quot;

date &gt;&gt; &quot;$LOG_FILE&quot;
echo &quot;Start deployment&quot; &gt;&gt;&quot;$LOG_FILE&quot;
cd /Path/need/be/deployed/
echo &quot;pulling source code...&quot; &gt;&gt; &quot;$LOG_FILE&quot;
git checkout origin gh-pages
git pull origin gh-pages
echo &quot;Finished.&quot; &gt;&gt;&quot;$LOG_FILE&quot;
echo &gt;&gt; $LOG_FILE
</code></pre>

<p>每当接收到带push的post请求时，执行上面的脚本。</p>

<h4 id="toc_7">6.2 处理post请求</h4>

<p>注：以下nodejs内容摘自<a href="http://www.lovelucy.info/auto-deploy-website-by-webhooks-of-github-and-gitlab.html">曾曦前辈博客－尘埃落定</a></p>

<blockquote>
<p>然后我们就要写一个脚本在 <a href="http://dev.lovelucy.info/incoming">http://dev.lovelucy.info/incoming</a> 这里接受 POST 请求了。因为本人机器上跑的是 node，俺就找了个 nodejs 的中间件 github-webhook-handler 。如果你要部署的是 PHP 网站，那你应该找一个世界上最好的语言 PHP 的版本，或者自己写一个，只需要接收 $_POST 嘛，好简单的，不多废话啦。么么哒 ( • ̀ω•́ )</p>
</blockquote>

<pre><code>$ npm install -g github-webhook-handler
</code></pre>

<blockquote>
<p>鉴于在天朝的服务器上 npm 拉 repo 比拉屎还难的状况，我们可以 选用 阿里的镜像，据说 10 分钟和官方同步一次。_(:3 」∠ )_</p>
</blockquote>

<pre><code>$ npm install -g cnpm --registry=http://r.cnpmjs.org
$ cnpm install -g github-webhook-handler
</code></pre>

<blockquote>
<p>好了，万事俱备，下面是 NodeJS 的监听程序 deploy.js</p>
</blockquote>

<pre><code>var http = require(&#39;http&#39;)
var createHandler = require(&#39;github-webhook-handler&#39;)
var handler = createHandler({ path: &#39;/incoming&#39;, secret: &#39;myHashSecret&#39; }) 
// 上面的 secret 保持和 GitHub 后台设置的一致
 
function run_cmd(cmd, args, callback) {
  var spawn = require(&#39;child_process&#39;).spawn;
  var child = spawn(cmd, args);
  var resp = &quot;&quot;;
 
  child.stdout.on(&#39;data&#39;, function(buffer) { resp += buffer.toString(); });
  child.stdout.on(&#39;end&#39;, function() { callback (resp) });
}
 
http.createServer(function (req, res) {
  handler(req, res, function (err) {
    res.statusCode = 404
    res.end(&#39;no such location&#39;)
  })
}).listen(7777)
 
handler.on(&#39;error&#39;, function (err) {
  console.error(&#39;Error:&#39;, err.message)
})
 
handler.on(&#39;push&#39;, function (event) {
  console.log(&#39;Received a push event for %s to %s&#39;,
    event.payload.repository.name,
    event.payload.ref);
  run_cmd(&#39;sh&#39;, [&#39;./deploy.sh&#39;], function(text){ console.log(text) });
})
 
/*
handler.on(&#39;issues&#39;, function (event) {
  console.log(&#39;Received an issue event for % action=%s: #%d %s&#39;,
    event.payload.repository.name,
    event.payload.action,
    event.payload.issue.number,
    event.payload.issue.title)
})
*/
</code></pre>

<p>之后把服务器跑起来就可以了。</p>

<pre><code>$ nodejs deploy.js
</code></pre>

<p>为了防止服务挂掉，我们有很多方式可以处理。我选择了用系统自带的nohup。</p>

<pre><code>$ nohup nodejs deply.js &amp;
</code></pre>

<p>曾曦前辈使用的是 NodeJs的forever，也可以使用python的supervisor。<br/>
<a href="http://www.lovelucy.info/auto-deploy-website-by-webhooks-of-github-and-gitlab.html">曾曦前辈博客－尘埃落定</a>有相关介绍。</p>

<h4 id="toc_8">6.3 配置Webhooks监听</h4>

<p>将Payload URL指向自己服务器的接口<br/>
<img src="media/14691078063823/14691103881759.jpg" alt=""/></p>

<pre><code>var handler = createHandler({ path: &#39;/incoming&#39;, secret: &#39;myHashSecret&#39; })

http.createServer(function (req, res) {
  handler(req, res, function (err) {
    res.statusCode = 404
    res.end(&#39;no such location&#39;)
  })
}).listen(7777)
</code></pre>

<p>这是deploy.js 的关键代码。<br/>
listen(7777)，表明服务器监听的是7777端口<br/>
path:&#39;/incoming&#39;，表示在 ip:7777/incoming 接收POST请求<br/>
secret: &#39;myHashSecret&#39;, 要求和上图的Secret字段一样，不然服务器会因为不匹配，拒绝接收到的请求。主要为了防止第三方向这个端口发送请求。</p>

<h2 id="toc_9">7. 最后梳理一下</h2>

<p><strong>6.3 那里知道什么时候有人提交文章了，然后告诉6.2 有人push</strong><br/>
<strong>6.2 从6.3 得到消息，看下你的密码(secret)和我的一样不，如果一样，我就把这个消息告诉6.1</strong><br/>
<strong>6.1 开始跑到github数据库拉取最新的数据，部署完成</strong></p>

<h2 id="toc_10">澄清</h2>

<p>有朋友告诉我，复制粘贴的部分比较多。即便加了转载说明，也不是很好。<br/>
在这里澄清一下：<br/>
网络上技术文章特点：<strong>多</strong>，<strong>杂</strong>，<strong>全</strong><br/>
可用的经典实例: <strong>少</strong><br/>
自生产实例的成本: <strong>费时</strong><br/>
一篇<strong>全原创</strong>的优质文章需要：<strong>思考</strong>＋<strong>原创实例</strong>＋<strong>码字</strong>＋<strong>重复前三项</strong> 。<br/>
而对于学习者而言，<strong>思想＋实例＋思路</strong>已经满足80%。<br/>
所以我认为，一篇能学到东西的技术文章，并不需要<strong>全原创</strong>。<br/>
清晰的思路＋前人提供的经典实例＋个人思考，传达到位即可。</p>

<p><strong>前人都总结好了，你再发一遍，不是制造网络垃圾吗？</strong><br/>
打造一个以思路清晰著称的博客，专注于技术文章整理、重成文是本博客存在的意义。我不是垃圾的生产者，我是大自然的清道夫。</p>

<p>欢迎关注个人微博<a href="http://weibo.com/2293237681">斯科特</a>，进行技术、非技术交流。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[10分钟快速搭建无限制流量的"VPN"（shadowsocks协议）]]></title>
    <link href="lixindong.top/14686843615662.html"/>
    <updated>2016-07-16T23:52:41+08:00</updated>
    <id>lixindong.top/14686843615662.html</id>
    <content type="html"><![CDATA[
<p>Too Long No Read： 阅读标题和标重点部分就能了解全部内容。</p>

<h2 id="toc_0">1. 简介</h2>

<p>良心声明: 有朋友说10分钟根本连文章都看不完，哪能建起个自己完全不熟悉的V P N 呢？<br/>
所以在这里必须解释一波：10分钟指的是开始动手到可以使用的时间。并不包括读这篇文章的时间，也不包括你在搭建服务过程中自我纠结的时间（比如，租多大的服务器？用什么密码？剁完手后又要饿多久的肚子才能给女票买下件内衣？之类。别问我为什么知道你一定是男的）最后，不包括运行出错，调试测试的时间。因为，按我说的做，你根本不可能失败！</p>

<p>接下来是简介：<br/>
说是无限制流量，其实骗你的啦（可爱）。说是VPN，其实不限于VPN。（本文搭建的也不是VPN，而是被称为Shadowsocks的协议。）<br/>
接下来解释：<br/>
<strong>原理:</strong> 租一个国外的服务器 --&gt;这个服务器上搭建自己的VPN --&gt; 通过这个VPN科学上网。<br/>
<strong>无限制流量：</strong>500G，1T，甚至更多。一月这么多，用的完吗？用不完不就相当于无限制。<br/>
<strong>VPN：</strong>既然有了自己墙外的服务器，就可以用它搭建任何自己想要的科学上网利器。本文章主要介绍当下最安全、最流行的<strong>ShadowSocks</strong>.<br/>
<strong>价格：</strong>很便宜！！很便宜！！很便宜！！</p>

<h2 id="toc_1">2. 工具篇</h2>

<h3 id="toc_2">2.1 VPS 国外的服务器</h3>

<p><strong>VPS：</strong>Virtual Private Server 虚拟专用服务器<br/>
其实你就知道是个自己能用来搭建科学上网服务的主机就行了。<br/>
一般不了解的人，第一反应都是：卧槽，我指用个10G流量只能翻墙的VPN就几十块一个月。那租一个可以干很多事情、不限流量的服务器，岂不要几百几千？其实不用998、不用98，绝对用你想不到的价格，买到最不可思议的产品！<br/>
<strong>推荐：</strong></p>

<h4 id="toc_3">1. 搬瓦工 (便宜推荐)</h4>

<p><strong>优点：</strong>便宜！！最低500G流量，年购19.99美刀，使用优惠码还可以再减1刀左右。相当于每月10元。这价格已经比大多数VPN便宜了。<br/>
<strong>支持支付宝交易！</strong><br/>
<strong>支持30天内退款</strong> 一般一个工作日内就能回复，支付宝收到2～3天。<br/>
<strong>一键配置shadowsocks！</strong>如果使用搬瓦工，那后面的内容都不用看了，点下面的链接注册即可。<br/>
官方网址：<a href="https://bandwagonhost.com/">https://bandwagonhost.com/</a></p>

<p>数据中心：美国西雅图、佛罗里达、洛杉矶、荷兰 套餐价格：64MB内存年3.99美元 / 96MB内存年4.99美元/128MB内存年5.99美元/512MB内存年9.99美元 简单介绍：IT7官方旗下的低价VPS主机产品，拥有速度较好的西岸亚利桑那州机房，最低年付仅需3.99美元，我们可以用来学习、工作项目演示，以及需要支持PPP/TUN搭建工具使用需求。拥有4个数据中心，而且可以自由切换IP，更换不同的IP，解决IP被封问题。<br/>
    •   CPU：1核心CPU<br/>
    •   内存：256MB<br/>
    •   硬盘：10GB SSD<br/>
    •   流量：500GB<br/>
    •   端口：1Gbps<br/>
    •   架构：OpenVZ+KiwiVM面板<br/>
    •   IP数：1独立IP<br/>
    •   系统：Linux<br/>
    •   价格：<strong>$19.99/年</strong>（购买）</p>

<pre><code>•   CPU：1核心CPU
•   内存：4096MB
•   硬盘：30GB SSD
•   流量：2000GB
•   端口：1Gbps
•   架构：OpenVZ+KiwiVM面板
•   IP数：1独立IP
•   系统：Linux
•   价格：$6.99/月（购买）

•   CPU：1核心CPU
•   内存：512MB
•   硬盘：10GB SSD
•   流量：1000GB
•   端口：1Gbps
•   架构：OpenVZ+KiwiVM面板
•   IP数：1独立IP
•   系统：Linux
•   价格：$19.99/年（弗里蒙特）

•   CPU：1核心CPU
•   内存：1024MB
•   硬盘：20GB SSD
•   流量：2000GB
•   端口：1Gbps
•   架构：OpenVZ+KiwiVM面板
•   IP数：1独立IP
•   系统：Linux
•   价格：$49.99/年（弗里蒙特）

•   CPU：2核心CPU
•   内存：512MB
•   硬盘：20GB SSD
•   流量：1000GB
•   端口：1Gbps
•   架构：OpenVZ+KiwiVM面板
•   IP数：1独立IP
•   系统：Linux
•   价格：$4.99/月（购买）

•   CPU：3核心CPU
•   内存：1024MB
•   硬盘：40GB SSD
•   流量：2000GB
•   端口：1Gbps
•   架构：OpenVZ+KiwiVM面板
•   IP数：1独立IP
•   系统：Linux
•   价格：$9.99/月（购买）
</code></pre>

<h4 id="toc_4">2. Vultr （稳定推荐，我自己目前在用）</h4>

<p><a href="http://www.vultr.com/?ref=6920216">注册网址</a><br/>
<strong>优点</strong> <br/>
1. 注册赠送20美金。使用最低标准服务5刀/月，相当于可以免费使用4个月。<br/>
2. 服务稳定。至少我还没碰到过当机情况。<br/>
3. 第三点是缺点，想获得20美金，必须使用信用卡支付，并且扣除2.5美元的验证费。（以后会返还）<br/>
<a href="http://www.vultr.com/?ref=6921913-3B">点击注册并获取20美金</a></p>

<p>数据中心：日本、洛杉矶、英国、法国、德国、荷兰、澳大利亚等14个机房<br/>
套餐价格：KVM 768MB 15GB SSD 1TB月流量 <strong>$5/月</strong><br/>
简单介绍：Vultr作为全球最大的游戏主机提供商背景之一，上线之后以高质的性价比、12个数据中心，以及新注册账户赠送5美金的账户使用金优惠促销，吸引广大的用户。作为我们用户，日本、洛杉矶等数据中心速度较好，如果有需要海外其他机房也可以在其12个数据中心中选择到适合自己的。</p>

<p>官方网站：<a href="https://www.vultr.com">https://www.vultr.com</a></p>

<h4 id="toc_5">3. 其它</h4>

<p>因为我指用过上面两个，所以其他的也不多介绍了。列个列表，大家可以自行google。<br/>
Linode: 很多人推荐。速度快。价格中等。<br/>
DigitalOcean: 很多人推荐。速度快，价格差不多。</p>

<h4 id="toc_6">为什么说价格便宜</h4>

<p>除了明码标价的价格。其实本身已经和普通VPN价格差不多了。但是仍然，有一点。虽然流量并不是无限，但是带宽并没有限制。就是说，在流量还够用的前提下，和朋友一起使用，是几乎不影响访问速度的，价格又能再除以...,最后折算下来非常可观。当然，不能超越物理极限，3、5个人一起用，是保险又便利的方式。</p>

<h4 id="toc_7">价格上，贵就是好</h4>

<p>对于同类物品，贵就是好。所以无论是我提到的，还是没提到的，虽然价格有差异，但是毕竟体现在服务好坏上。所以，如果你发现不同价格，买到了同样的配置，但是实际效果却有差距，这很正常。</p>

<h3 id="toc_8">2.2 Python Shadowsocks 搭建服务的工具和协议</h3>

<p>Shadowsocks 属于socks5 代理，稳定性好，抗干扰能力强。</p>

<h4 id="toc_9">搭建服务 三步走</h4>

<p>1 . 安装<br/>
 在CentOS中运行下面两条命令就完成了shadowsocks的安装了：</p>

<pre><code>yum install python-setuptools &amp;&amp; easy_install pip
pip install shadowsocks
</code></pre>

<p>2 . 配置<br/>
完成之后创建一个配置文件 /etc/shadowsocks.json，写入以下内容：</p>

<pre><code>{ 
        &quot;server&quot;:&quot;0.0.0.0&quot;,            #服务器IP地址
        &quot;server_port&quot;:8388,                 #服务监听端口
        &quot;local_port&quot;:1080,                  #本地连接端口
        &quot;password&quot;:&quot;barfoo&quot;,               #加密传输使用到的密码
        &quot;timeout&quot;:600,                      #连接超时时间
        &quot;method&quot;:&quot;aes-256-cfb&quot;,             #加密算法
}
</code></pre>

<p>3 . 启动、停止<br/>
运行下面的命令来启动和停止后台服务：</p>

<pre><code class="language-ssserver">ssserver -c /etc/shadowsocks.json -d stop
</code></pre>

<h4 id="toc_10">然后你就可以使用上面的配置连接shadowsocks了。</h4>

<ol>
<li>客户端如何用？</li>
</ol>

<p>各个平台使用的客户端都有差异，但是用到的信息就这些：<br/>
－ 服务器IP: 不是上面的0.0.0.0，是你申请的VPS，会提供一个ip。打开网站，登录，找到它<br/>
－ 端口(port): 8388<br/>
－ 协议类型: aes-256-cfb 一般默认就这个，不用换。但还是要看一眼。<br/>
－ 密码(password): barfoo<br/>
连接，欢呼。</p>

<h2 id="toc_11">3. 拓展</h2>

<p>可以点赞了。</p>

<p>欢迎关注微博进行技术交流 <a href="http://weibo.com/2293237681">斯科特</a><br/>
**</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PokemonGo破解]]></title>
    <link href="lixindong.top/14685051740290.html"/>
    <updated>2016-07-14T22:06:14+08:00</updated>
    <id>lixindong.top/14685051740290.html</id>
    <content type="html"><![CDATA[
<ol>
<li>简单的更改unity位置
报错
<code>07-14 22:04:02.801 7512-9260/? E/NianticAccountManager: User cannot be authenticated.
                                                    com.google.android.gms.auth.GoogleAuthException: INVALID_AUDIENCE
                                                        at com.google.android.gms.auth.GoogleAuthUtil.zza(Unknown Source)
                                                        at com.google.android.gms.auth.GoogleAuthUtil.getToken(Unknown Source)
                                                        at com.google.android.gms.auth.GoogleAuthUtil.getToken(Unknown Source)
                                                        at com.google.android.gms.auth.GoogleAuthUtil.getToken(Unknown Source)
                                                        at com.nianticlabs.nia.account.NianticAccountManager.getAccount(NianticAccountManager.java:75)</code></li>
</ol>

<h2 id="toc_0">测试一下是否有签名登录保护之类的策略。</h2>

<p>使用apk反编译后直接重新打包，打开app。<br/>
google账号鉴权成功。没问题！</p>

<h2 id="toc_1">测试做些简单的修改</h2>

<p><code>    invoke-virtual {p0, v0}, Lcom/kodelabs/boilerplate/presentation/ui/activities/MainActivity;-&gt;updateLocation(Landroid/location/Location;)V</code><br/>
<code><br/>
.method public updateLocation(Landroid/location/Location;)V<br/>
    .locals 2<br/>
    .param p1, &quot;location&quot;    # Landroid/location/Location;</p>

<pre><code>.prologue
.line 31
const-wide v0, -0x3fa7170e2c12ad82L    # -99.63976

invoke-virtual {p1, v0, v1}, Landroid/location/Location;-&gt;setLongitude(D)V

.line 32
const-wide v0, 0x4043d0087ca643ccL    # 39.625259

invoke-virtual {p1, v0, v1}, Landroid/location/Location;-&gt;setLatitude(D)V

.line 33
return-void
</code></pre>

<p>.end method</code></p>

<h2 id="toc_2">打包安装</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Creating a Navigation Drawer]]></title>
    <link href="lixindong.top/14583860309318.html"/>
    <updated>2016-03-19T19:13:50+08:00</updated>
    <id>lixindong.top/14583860309318.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">表现</h2>

<p>Navigation Drawer <br/>
<img src="media/14583860309318/14583864312339.jpg" alt=""/></p>

<p>手指从屏幕左边右滑，打开的这个像 Menu 一样的的页面就被称为 NavigationDrawer。<br/>
谷歌在 MD 规范中详细说明了它的设计规范，在开始设计你的应用时请务必阅读作为参考。<br/>
<a href="http://developer.android.com/design/patterns/navigation-drawer.html">Navigation Drawer</a></p>

<h2 id="toc_1">实现思路</h2>

<p>分析一下，很容易看出来，基本是分为两层。上层的这个 Drawer 层(包含你看到的这个 View 和可能被忽略的覆盖下层的阴影)，下层的包含了页面本身的内容层(ActionBar TabLayout 其它内容)。</p>

<h2 id="toc_2">使用方式</h2>

<p>所以，使用也很符合思考模式：以 DrawerLayout 为根 View 包含两层子 View。</p>

<h3 id="toc_3">1. XML 文件</h3>

<pre><code class="language-&lt;android.support.v4.widget.DrawerLayout">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:id=&quot;@+id/drawer_layout&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;
    &lt;!-- The main content view --&gt;
    &lt;FrameLayout
        android:id=&quot;@+id/content_frame&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot; /&gt;
    &lt;!-- The navigation drawer --&gt;
    &lt;ListView android:id=&quot;@+id/left_drawer&quot;
        android:layout_width=&quot;240dp&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_gravity=&quot;start&quot;
        android:choiceMode=&quot;singleChoice&quot;
        android:divider=&quot;@android:color/transparent&quot;
        android:dividerHeight=&quot;0dp&quot;
        android:background=&quot;#111&quot;/&gt;
&lt;/android.support.v4.widget.DrawerLayout&gt;
</code></pre>

<p><strong>注意的点</strong><br/>
*  内容层必须是DrawerLayout 的第一个子 View。因为 XML 以 View 的顺序决定 Z 的次序。<br/>
*  drawer 层必须设定 android:layout_gravity 属性。用来支持 right-to-left 语言。注意用 &quot;start&quot; 代替 &quot;left&quot;。<br/>
*  drawer 层的宽度小于320dp，这样展开时也能看到下方的内容。高度 match_parent。</p>

<h3 id="toc_4">2. 代码对内容进行配置</h3>

<pre><code>public class MainActivity extends Activity {
    private String[] mPlanetTitles;
    private DrawerLayout mDrawerLayout;
    private ListView mDrawerList;
    ...

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        mPlanetTitles = getResources().getStringArray(R.array.planets_array);
        mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout);
        mDrawerList = (ListView) findViewById(R.id.left_drawer);

        // Set the adapter for the list view
        mDrawerList.setAdapter(new ArrayAdapter&lt;String&gt;(this,
                R.layout.drawer_list_item, mPlanetTitles));
        // Set the list&#39;s click listener
        mDrawerList.setOnItemClickListener(new DrawerItemClickListener());

        ...
    }
}
</code></pre>

<h3 id="toc_5">3. 处理其它问题</h3>

<h4 id="toc_6">3.1 处理点击事件导航</h4>

<p>给 Drawer 的 ListView 设置 OnItemClickListener 就行。<br/>
<strong>示例代码</strong><br/>
```<br/>
private class DrawerItemClickListener implements ListView.OnItemClickListener {<br/>
    @Override<br/>
    public void onItemClick(AdapterView parent, View view, int position, long id) {<br/>
        selectItem(position);<br/>
    }<br/>
}</p>

<p>/** Swaps fragments in the main content view */<br/>
private void selectItem(int position) {<br/>
    // Create a new fragment and specify the planet to show based on position<br/>
    Fragment fragment = new PlanetFragment();<br/>
    Bundle args = new Bundle();<br/>
    args.putInt(PlanetFragment.ARG_PLANET_NUMBER, position);<br/>
    fragment.setArguments(args);</p>

<pre><code>// Insert the fragment by replacing any existing fragment
FragmentManager fragmentManager = getFragmentManager();
fragmentManager.beginTransaction()
               .replace(R.id.content_frame, fragment)
               .commit();

// Highlight the selected item, update the title, and close the drawer
mDrawerList.setItemChecked(position, true);
setTitle(mPlanetTitles[position]);
mDrawerLayout.closeDrawer(mDrawerList);
</code></pre>

<p>}</p>

<p>@Override<br/>
public void setTitle(CharSequence title) {<br/>
    mTitle = title;<br/>
    getActionBar().setTitle(mTitle);<br/>
}<br/>
```</p>

<h4 id="toc_7">监听 Drawer 展开、关闭事件</h4>

<p>调用 DrawerLayout.setDrawerListener() 方法，传递一个 DrawerLayout.DrawerListener 接口的实现。<br/>
实现这个接口有两种方式。<br/>
1. 直接实现 DrawerListener.<br/>
2. 写一个继承 ActionBarDrawerToggle 的子类，这个类实现了这个接口，你可以在子类中重写 DrawerListener 接口函数。</p>

<p><strong>示例代码</strong><br/>
```<br/>
public class MainActivity extends Activity {<br/>
    private DrawerLayout mDrawerLayout;<br/>
    private ActionBarDrawerToggle mDrawerToggle;<br/>
    private CharSequence mDrawerTitle;<br/>
    private CharSequence mTitle;<br/>
    ...</p>

<pre><code>@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    ...

    mTitle = mDrawerTitle = getTitle();
    mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout);
    mDrawerToggle = new ActionBarDrawerToggle(this, mDrawerLayout,
            R.drawable.ic_drawer, R.string.drawer_open, R.string.drawer_close) {

        /** Called when a drawer has settled in a completely closed state. */
        public void onDrawerClosed(View view) {
            super.onDrawerClosed(view);
            getActionBar().setTitle(mTitle);
            invalidateOptionsMenu(); // creates call to onPrepareOptionsMenu()
        }

        /** Called when a drawer has settled in a completely open state. */
        public void onDrawerOpened(View drawerView) {
            super.onDrawerOpened(drawerView);
            getActionBar().setTitle(mDrawerTitle);
            invalidateOptionsMenu(); // creates call to onPrepareOptionsMenu()
        }
    };

    // Set the drawer toggle as the DrawerListener
    mDrawerLayout.setDrawerListener(mDrawerToggle);
}

/* Called whenever we call invalidateOptionsMenu() */
@Override
public boolean onPrepareOptionsMenu(Menu menu) {
    // If the nav drawer is open, hide action items related to the content view
    boolean drawerOpen = mDrawerLayout.isDrawerOpen(mDrawerList);
    menu.findItem(R.id.action_websearch).setVisible(!drawerOpen);
    return super.onPrepareOptionsMenu(menu);
}
</code></pre>

<p>}<br/>
```</p>

<h4 id="toc_8">通过 App Icon 打开、关闭 Drawer</h4>

<p>通过使用 ActionBarDrawerToggle 类，可以控制这些行为。<br/>
* 点击控制 Drawer 行为<br/>
* 指定展开时的 icon</p>

<p>标准的导航 Icon 图标在 (Download the Action Bar Icon Pack)[<a href="http://developer.android.com/downloads/design/Android_Design_Icons_20130926.zip">http://developer.android.com/downloads/design/Android_Design_Icons_20130926.zip</a>]</p>

<p>最后你需要在 Activity 的生命周期中使用 ActionBarDrawerToggle 的这些方法。<br/>
<strong>示例代码</strong><br/>
```<br/>
public class MainActivity extends Activity {<br/>
    private DrawerLayout mDrawerLayout;<br/>
    private ActionBarDrawerToggle mDrawerToggle;<br/>
    ...</p>

<pre><code>public void onCreate(Bundle savedInstanceState) {
    ...

    mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout);
    mDrawerToggle = new ActionBarDrawerToggle(
            this,                  /* host Activity */
            mDrawerLayout,         /* DrawerLayout object */
            R.drawable.ic_drawer,  /* nav drawer icon to replace &#39;Up&#39; caret */
            R.string.drawer_open,  /* &quot;open drawer&quot; description */
            R.string.drawer_close  /* &quot;close drawer&quot; description */
            ) {

        /** Called when a drawer has settled in a completely closed state. */
        public void onDrawerClosed(View view) {
            super.onDrawerClosed(view);
            getActionBar().setTitle(mTitle);
        }

        /** Called when a drawer has settled in a completely open state. */
        public void onDrawerOpened(View drawerView) {
            super.onDrawerOpened(drawerView);
            getActionBar().setTitle(mDrawerTitle);
        }
    };

    // Set the drawer toggle as the DrawerListener
    mDrawerLayout.setDrawerListener(mDrawerToggle);

    getActionBar().setDisplayHomeAsUpEnabled(true);
    getActionBar().setHomeButtonEnabled(true);
}

@Override
protected void onPostCreate(Bundle savedInstanceState) {
    super.onPostCreate(savedInstanceState);
    // Sync the toggle state after onRestoreInstanceState has occurred.
    mDrawerToggle.syncState();
}

@Override
public void onConfigurationChanged(Configuration newConfig) {
    super.onConfigurationChanged(newConfig);
    mDrawerToggle.onConfigurationChanged(newConfig);
}

@Override
public boolean onOptionsItemSelected(MenuItem item) {
    // Pass the event to ActionBarDrawerToggle, if it returns
    // true, then it has handled the app icon touch event
    if (mDrawerToggle.onOptionsItemSelected(item)) {
      return true;
    }
    // Handle your other action bar items...

    return super.onOptionsItemSelected(item);
}
...
</code></pre>

<p>}<br/>
```</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Smartoo 开发中遇到的问题和解决]]></title>
    <link href="lixindong.top/14539061256073.html"/>
    <updated>2016-01-27T22:48:45+08:00</updated>
    <id>lixindong.top/14539061256073.html</id>
    <content type="html"><![CDATA[
<p><code>Weibo客户端sso认证不成功</code><br/>
uri mismatch 的问题是因为weibo开放平台配置有延迟，在平台上修改redirect uri后，隔天就可以通过了<br/>
闪退的问题，可能是由于不是打的release的包，做reader的分享时就有这样的问题。明天用release的包测试一下。<br/>
使用web验证可以顺利通过。</p>

<p><code>未通过审核帐号的接口调用限制</code><br/>
大概在200-300次之间</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[风の诗(风之诗 Wind Song)]]></title>
    <link href="lixindong.top/14530335489771.html"/>
    <updated>2016-01-17T20:25:48+08:00</updated>
    <id>lixindong.top/14530335489771.html</id>
    <content type="html"><![CDATA[
<p>F4 </p>

<h2 id="toc_0">音程</h2>

<p>n度  大n度  小n度<br/>
和弦  和谐，不和谐<br/>
和弦 根音＋1 3 5度，小三度＋大三度  minor和弦， 大三度＋小三度 大和弦， 小三度＋小三度 减和弦</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[下町火箭]]></title>
    <link href="lixindong.top/14488126785387.html"/>
    <updated>2015-11-29T23:57:58+08:00</updated>
    <id>lixindong.top/14488126785387.html</id>
    <content type="html"><![CDATA[
<p><img src="http://i12.tietuku.com/82e26086176beb7c.png" alt="http://i12.tietuku.com/82e26086176beb7c.png"/><br/>
《下町火箭》讲述的是小小的佃制造所通过努力，成功帮助帝国重工将火箭升空的一系列感人的故事。<br/>
通常这类故事都会被打上励志的标签，本剧却不止于此。</p>

<p>如何能够在一次火箭发射失败后从头再来，潜心研究。如何平衡工作和女儿的关系。如何能像信任自己的孩子一般信任自己的作品。<br/>
《下町火箭》更多讲的是人看待梦想的态度，人与人之间的羁绊。</p>

<p>日剧总是把人们的这些感情解读并重点展现出来，这也是为什么我会对日剧如此钟爱。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[app 我有一个问题]]></title>
    <link href="lixindong.top/14464734385012.html"/>
    <updated>2015-11-02T22:10:38+08:00</updated>
    <id>lixindong.top/14464734385012.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>这个app不是问答式的社区</p>
</blockquote>

<h2 id="toc_0">疑问</h2>

<p>人每天都会产生疑问，但每天也有疑问被搁置下来，没有解答<br/>
想想，如果这些问题全部或者大部分都能被解决并记录。那么一年以后的自己将会变得多么博学</p>

<h2 id="toc_1">想想，这些问题被搁置的原因</h2>

<ul>
<li><strong>时间</strong>:   “我在做其它事情，分不开时间”</li>
<li><strong>优先级</strong>:  “其实问题也不是那么重要”</li>
<li><strong>复杂性</strong>:  “这可能不是一会儿能了解的”</li>
<li><strong>领域</strong>:   “无从下手”</li>
<li><strong>人真是复杂慵懒的动物</strong>:   “想之后解决，然后就忘记了，或者想起来也没兴趣了”</li>
<li><strong>比干货更简洁</strong>:   “我只想知道个大概，可网上的答案总不能让我满意。要么太全面，要么没讲到点”</li>
</ul>

<blockquote>
<p>没能在产生疑问的<strong>时间</strong>，找到合适的<strong>资料</strong>,和那个能一句话讲到点的<strong>人</strong>。</p>
</blockquote>

<h2 id="toc_2">因此，我们需要什么</h2>

<p>正式点讲 <strong>最简洁，最get到point的回答</strong><br/>
不正式点 <strong>最右神回复</strong></p>

<blockquote>
<p>然而提供内容并不是我们要做的</p>

<p>人从心底总是自私的<br/>
即便在<em>知乎</em>这类为他人服务的平台上，人们也总是倾向于回答自己感兴趣的提问</p>
</blockquote>

<h2 id="toc_3">如何做</h2>

<p>因此，<br/>
我们只是提供给用户一个私人的<strong>记录平台</strong>, 个人的问题<strong>管理平台</strong></p>

<h4 id="toc_4">定位：</h4>

<ul>
<li>个人手账类的记事本</li>
<li>将公开内容聚合的知识库</li>
<li>社区</li>
</ul>

<h4 id="toc_5">功能</h4>

<ul>
<li>随时定义新概念：有时为了讲解方便，需要用一个词代替一个概念。在当下没有相应的概念时，一个新的概念词诞生是被允许和值得推荐的。我们也有机制推荐其中优秀和广为传播的新概念。</li>
<li>随时记录新疑问</li>
<li>对于未填补答案的问题

<ul>
<li>自动归档到todo</li>
<li>手动填补答案</li>
<li>查看知识库中推荐的已有答案</li>
<li>公开征求答案</li>
<li>选择合适的答案mark到自己的手账中</li>
</ul></li>
<li>对于已填补的问题

<ul>
<li>根据艾宾浩斯记忆法，进行复习</li>
<li>知识库中有相关问题的优解，推荐</li>
<li>在知识库中作为备选答案，接受其它用户浏览、评分</li>
</ul></li>
<li>知识库的答案全部由运营商或其它用户提供</li>
<li>打赏功能：对于很好地解决了自己问题的<strong>优质</strong>答案，用户可选择进行打赏</li>
<li>专题功能：专家级的用户可以创建自己的专题，专题内容通过一定的标准（质与量），可以将其电子版内容打包出售</li>
<li>发烧圈子：可由专题、小组组成。是人的圈子，也是内容的圈子。一个内容可以在某个圈子发表，圈子内可见。一个用户可以在圈子中被推荐。</li>
<li>热门的分类社区：howto类，购物类，等</li>
</ul>

<h4 id="toc_6">用户群体</h4>

<ul>
<li>文青</li>
<li>动手达人</li>
<li>领域专家</li>
<li>爱思考的人</li>
<li>拖延症患者</li>
<li>除上面以外的其他人</li>
</ul>

<h4 id="toc_7">盈利模式</h4>

<p>这是我的一个问题。期待社区帮我解答。</p>

<h2 id="toc_8">最后</h2>

<p><strong>我们希望并渴求精炼的一句话答案</strong> <br/>
帮助大多数人瞬间开窍</p>

<p><strong>我们也渴望专业级别的教科书</strong><br/>
提升你自己的同时，带给世界更优质的内容</p>

]]></content>
  </entry>
  
</feed>
